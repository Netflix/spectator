{
    "docs": [
        {
            "location": "/", 
            "text": "Simple library for instrumenting code to record dimensional time series. If\nyou are new to the library it is highly recommended to read the pages in the\n\nGetting Started\n section on the sidebar.\n\n\nAt a minimum you will need to:\n\n\n\n\nDepend on the api library. It is in maven central, for gradle the dependency\n   would be \ncom.netflix.spectator:spectator-api:0.58.0\n.\n\n\nInstrument some code, see the usage guides for \ncounters\n,\n   \ntimers\n, and \ngauges\n.\n\n\nPick a registry to bind to when initializing the application. See the sidebar\n   for a list of available registries.", 
            "title": "Home"
        }, 
        {
            "location": "/intro/registry/", 
            "text": "Registry\n\n\nThere are a few basic concepts you need to learn to use Spectator.\nThe \nregistry\n\nis the main class for managing a set of meters. A meter is a class for collecting a set of\nmeasurements about your application.\n\n\nChoosing an Implementation\n\n\nThe core spectator library, \nspectator-api\n, comes with the following registry implementations:\n\n\n\n   \n\n     \nClass\n\n     \nDependency\n\n     \nDescription\n\n   \n\n   \n\n     \n\n       \n\n       \nDefaultRegistry\n\n       \n\n       \nspectator-api\n\n       \n\n       Updates local counters, frequently used with \nunit tests\n.\n       \n\n     \n\n     \n\n       \n\n       \nNoopRegistry\n\n       \n\n       \nspectator-api\n\n       \n\n       Does nothing, tries to make operations as cheap as possible. This implementation is\n       typically used to help understand the overhead being created due to instrumentation.\n       It can also be useful in testing to help ensure that no side effects were introduced\n       where the instrumentation is now needed in order for the application for function\n       properly.\n       \n\n     \n\n     \n\n       \n\n       \nServoRegistry\n\n       \n\n       \nspectator-reg-servo\n\n       \n\n       Map to \nservo library\n. This is the implementation\n       typically used at Netflix to report data into \nAtlas\n.\n       \n\n     \n\n     \n\n       \n\n       \nMetricsRegistry\n\n       \n\n       \nspectator-reg-metrics3\n\n       \n\n       Map to \nmetrics3 library\n. This implementation\n       is typically used for reporting to local files, JMX, or other backends like Graphite.\n       Note that it uses a hierarchical naming scheme rather than the dimensional naming\n       used by Spectator, so the names will get flattened when mapped to this registry.\n       \n\n     \n\n   \n\n \n\n\nIt is recommended for libraries to write code against the\n\nRegistry\n\ninterface and allow the implementation to get injected by the user of the library. The\nsimplest way is to accept the registry via the constructor, for example:\n\n\npublic\n \nclass\n \nHttpServer\n \n{\n\n  \npublic\n \nHttpServer\n(\nRegistry\n \nregistry\n)\n \n{\n\n    \n// use registry to collect measurements\n\n  \n}\n\n\n}\n\n\n\n\n\n\nThe user of the class can then provide the implementation:\n\n\nRegistry\n \nregistry\n \n=\n \nnew\n \nDefaultRegistry\n();\n\n\nHttpServer\n \nserver\n \n=\n \nnew\n \nHttpServer\n(\nregistry\n);\n\n\n\n\n\n\nMore complete examples can be found on the \ntesting page\n or in the\n\nspectator-examples repo\n.\n\n\nWorking With Ids\n\n\nSpectator is primarily intended for collecting data for dimensional time series\nbackends like \nAtlas\n. The ids used for looking\nup a meter in the registry consist of a name and set of tags. Ids will be consumed\nmany times by users after the data has been reported so they should be chosen with\nsome care and thought about how they will get used. See the \nconventions page\n\nfor some general guidelines.\n\n\nIds are created via the registry, for example:\n\n\nId\n \nid\n \n=\n \nregistry\n.\ncreateId\n(\nserver.requestCount\n);\n\n\n\n\n\n\nThe ids are immutable so they can be freely passed around and used in a concurrent\ncontext. Tags can be added when an id is created:\n\n\nId\n \nid\n \n=\n \nregistry\n.\ncreateId\n(\nserver.requestCount\n,\n \nstatus\n,\n \n2xx\n,\n \nmethod\n,\n \nGET\n);\n\n\n\n\n\n\nOr by using \nwithTag\n and \nwithTags\n on an existing id:\n\n\npublic\n \nclass\n \nHttpServer\n \n{\n\n  \nprivate\n \nfinal\n \nId\n \nbaseId\n;\n\n\n  \npublic\n \nHttpServer\n(\nRegistry\n \nregistry\n)\n \n{\n\n    \nbaseId\n \n=\n \nregistry\n.\ncreateId\n(\nserver.requestCount\n);\n\n  \n}\n\n\n  \nprivate\n \nvoid\n \nhandleRequestComplete\n(\nHttpRequest\n \nreq\n,\n \nHttpResponse\n \nres\n)\n \n{\n\n    \n// Remember Id is immutable, withTags will return a copy with the\n\n    \n// the additional metadata\n\n    \nId\n \nreqId\n \n=\n \nbaseId\n.\nwithTags\n(\n\n      \nstatus\n,\n \nres\n.\ngetStatus\n(),\n\n      \nmethod\n,\n \nreq\n.\ngetMethod\n().\nname\n());\n\n    \nregistry\n.\ncounter\n(\nreqId\n).\nincrement\n();\n\n  \n}\n\n\n  \nprivate\n \nvoid\n \nhandleRequestError\n(\nHttpRequest\n \nreq\n,\n \nThrowable\n \nt\n)\n \n{\n\n    \n// Can also be added individually using `withTag`. However, it is better\n\n    \n// for performance to batch modifications using `withTags`.\n\n    \nId\n \nreqId\n \n=\n \nbaseId\n\n      \n.\nwithTag\n(\nerror\n,\n  \nt\n.\ngetClass\n().\ngetSimpleName\n())\n\n      \n.\nwithTag\n(\nmethod\n,\n \nreq\n.\ngetMethod\n().\nname\n());\n\n    \nregistry\n.\ncounter\n(\nreqId\n).\nincrement\n();\n\n  \n}\n\n\n}\n\n\n\n\n\n\nCollecting Measurements\n\n\nOnce you have an id, the registry can be used to get an instance of a meter to\nrecord a measurement. Meters can roughly be categorized in two groups:\n\n\nActive\n\n\nActive meters are ones that are called directly when some event occurs. There are\nthree basic types supported:\n\n\n\n\nCounters\n: measures how often something is occuring. This will be\n  reported to backend systems as a rate per second. For example, number of requests\n  processed by web server.\n\n\nTimers\n: measures how long something took. For example, latency of\n  requests processed by a web server.\n\n\nDistribution Summaries\n: measures the size of something. For\n  example, entity sizes for requests processed by a web server.\n\n\n\n\nPassive\n\n\nPassive meters are ones where the registry just has a reference to get the value\nwhen needed. For example, the number of current connections on a web server or\nthe number threads that are currently in use. These will be \ngauges\n.\n\n\nGlobal Registry\n\n\nThere are some use-cases where injecting the registry is not possible or is too\ncumbersome. The main example from the core spectator libraries is the\n\nlog4j appender\n. The global registry is useful there because\nlogging is often initialized before any other systems and Spectator itself uses\nlogging via the slf4j api which is quite likely being bound to log4j when that\nthe appender is being used. By using the global registry the logging initialization\ncan proceed before the spectator initialization in the application. Though any\nmeasurements taken before a registry instance has been added will be lost.\n\n\nThe global registry is accessed using:\n\n\nRegistry\n \nregistry\n \n=\n \nSpectator\n.\nglobalRegistry\n();\n\n\n\n\n\n\nBy default it will not record anything. For a specific registry instance you can\nchoose to configure it to work with the global registry by calling \nadd\n:\n\n\npublic\n \nvoid\n \ninit\n()\n \n{\n\n  \nRegistry\n \nregistry\n \n=\n \n// Choose an appropriate implementation\n\n\n  \n// Add it to the global registry so it will receive\n\n  \n// any activity on the global registry\n\n  \nSpectator\n.\nglobalRegistry\n().\nadd\n(\nregistry\n);\n\n\n}\n\n\n\n\n\n\nAny measurements taken while no registries are added to the global instance will\nbe lost. If multiple registries are added, all will recieve updates made to the global\nregistry.", 
            "title": "Registry"
        }, 
        {
            "location": "/intro/registry/#registry", 
            "text": "There are a few basic concepts you need to learn to use Spectator.\nThe  registry \nis the main class for managing a set of meters. A meter is a class for collecting a set of\nmeasurements about your application.", 
            "title": "Registry"
        }, 
        {
            "location": "/intro/registry/#choosing-an-implementation", 
            "text": "The core spectator library,  spectator-api , comes with the following registry implementations:  \n    \n      Class \n      Dependency \n      Description \n    \n    \n      \n        \n        DefaultRegistry \n        \n        spectator-api \n        \n       Updates local counters, frequently used with  unit tests .\n        \n      \n      \n        \n        NoopRegistry \n        \n        spectator-api \n        \n       Does nothing, tries to make operations as cheap as possible. This implementation is\n       typically used to help understand the overhead being created due to instrumentation.\n       It can also be useful in testing to help ensure that no side effects were introduced\n       where the instrumentation is now needed in order for the application for function\n       properly.\n        \n      \n      \n        \n        ServoRegistry \n        \n        spectator-reg-servo \n        \n       Map to  servo library . This is the implementation\n       typically used at Netflix to report data into  Atlas .\n        \n      \n      \n        \n        MetricsRegistry \n        \n        spectator-reg-metrics3 \n        \n       Map to  metrics3 library . This implementation\n       is typically used for reporting to local files, JMX, or other backends like Graphite.\n       Note that it uses a hierarchical naming scheme rather than the dimensional naming\n       used by Spectator, so the names will get flattened when mapped to this registry.\n        \n      \n    \n   It is recommended for libraries to write code against the Registry \ninterface and allow the implementation to get injected by the user of the library. The\nsimplest way is to accept the registry via the constructor, for example:  public   class   HttpServer   { \n   public   HttpServer ( Registry   registry )   { \n     // use registry to collect measurements \n   }  }   The user of the class can then provide the implementation:  Registry   registry   =   new   DefaultRegistry ();  HttpServer   server   =   new   HttpServer ( registry );   More complete examples can be found on the  testing page  or in the spectator-examples repo .", 
            "title": "Choosing an Implementation"
        }, 
        {
            "location": "/intro/registry/#working-with-ids", 
            "text": "Spectator is primarily intended for collecting data for dimensional time series\nbackends like  Atlas . The ids used for looking\nup a meter in the registry consist of a name and set of tags. Ids will be consumed\nmany times by users after the data has been reported so they should be chosen with\nsome care and thought about how they will get used. See the  conventions page \nfor some general guidelines.  Ids are created via the registry, for example:  Id   id   =   registry . createId ( server.requestCount );   The ids are immutable so they can be freely passed around and used in a concurrent\ncontext. Tags can be added when an id is created:  Id   id   =   registry . createId ( server.requestCount ,   status ,   2xx ,   method ,   GET );   Or by using  withTag  and  withTags  on an existing id:  public   class   HttpServer   { \n   private   final   Id   baseId ; \n\n   public   HttpServer ( Registry   registry )   { \n     baseId   =   registry . createId ( server.requestCount ); \n   } \n\n   private   void   handleRequestComplete ( HttpRequest   req ,   HttpResponse   res )   { \n     // Remember Id is immutable, withTags will return a copy with the \n     // the additional metadata \n     Id   reqId   =   baseId . withTags ( \n       status ,   res . getStatus (), \n       method ,   req . getMethod (). name ()); \n     registry . counter ( reqId ). increment (); \n   } \n\n   private   void   handleRequestError ( HttpRequest   req ,   Throwable   t )   { \n     // Can also be added individually using `withTag`. However, it is better \n     // for performance to batch modifications using `withTags`. \n     Id   reqId   =   baseId \n       . withTag ( error ,    t . getClass (). getSimpleName ()) \n       . withTag ( method ,   req . getMethod (). name ()); \n     registry . counter ( reqId ). increment (); \n   }  }", 
            "title": "Working With Ids"
        }, 
        {
            "location": "/intro/registry/#collecting-measurements", 
            "text": "Once you have an id, the registry can be used to get an instance of a meter to\nrecord a measurement. Meters can roughly be categorized in two groups:", 
            "title": "Collecting Measurements"
        }, 
        {
            "location": "/intro/registry/#active", 
            "text": "Active meters are ones that are called directly when some event occurs. There are\nthree basic types supported:   Counters : measures how often something is occuring. This will be\n  reported to backend systems as a rate per second. For example, number of requests\n  processed by web server.  Timers : measures how long something took. For example, latency of\n  requests processed by a web server.  Distribution Summaries : measures the size of something. For\n  example, entity sizes for requests processed by a web server.", 
            "title": "Active"
        }, 
        {
            "location": "/intro/registry/#passive", 
            "text": "Passive meters are ones where the registry just has a reference to get the value\nwhen needed. For example, the number of current connections on a web server or\nthe number threads that are currently in use. These will be  gauges .", 
            "title": "Passive"
        }, 
        {
            "location": "/intro/registry/#global-registry", 
            "text": "There are some use-cases where injecting the registry is not possible or is too\ncumbersome. The main example from the core spectator libraries is the log4j appender . The global registry is useful there because\nlogging is often initialized before any other systems and Spectator itself uses\nlogging via the slf4j api which is quite likely being bound to log4j when that\nthe appender is being used. By using the global registry the logging initialization\ncan proceed before the spectator initialization in the application. Though any\nmeasurements taken before a registry instance has been added will be lost.  The global registry is accessed using:  Registry   registry   =   Spectator . globalRegistry ();   By default it will not record anything. For a specific registry instance you can\nchoose to configure it to work with the global registry by calling  add :  public   void   init ()   { \n   Registry   registry   =   // Choose an appropriate implementation \n\n   // Add it to the global registry so it will receive \n   // any activity on the global registry \n   Spectator . globalRegistry (). add ( registry );  }   Any measurements taken while no registries are added to the global instance will\nbe lost. If multiple registries are added, all will recieve updates made to the global\nregistry.", 
            "title": "Global Registry"
        }, 
        {
            "location": "/intro/counter/", 
            "text": "Counters\n\n\nA counter is used to measure the rate at which some event is occurring.\nConsider a simple queue, counters would be used to measure things like the\nrate at which items are being inserted and removed. \n\n\nCounters are created using the registry which will be setup as part of\napplication initialization. For example:\n\n\npublic\n \nclass\n \nQueue\n \n{\n\n\n  \nprivate\n \nfinal\n \nCounter\n \ninsertCounter\n;\n\n  \nprivate\n \nfinal\n \nCounter\n \nremoveCounter\n;\n\n  \nprivate\n \nfinal\n \nQueueImpl\n \nimpl\n;\n\n\n  \n@Inject\n\n  \npublic\n \nQueue\n(\nRegistry\n \nregistry\n)\n \n{\n\n    \ninsertCounter\n \n=\n \nregistry\n.\ncounter\n(\nqueue.insert\n);\n\n    \nremoveCounter\n \n=\n \nregistry\n.\ncounter\n(\nqueue.remove\n);\n\n    \nimpl\n \n=\n \nnew\n \nQueueImpl\n();\n\n  \n}\n\n\n\n\n\n\nThen call increment when an event occurs:\n\n\n  \npublic\n \nvoid\n \ninsert\n(\nObject\n \nobj\n)\n \n{\n\n    \ninsertCounter\n.\nincrement\n();\n\n    \nimpl\n.\ninsert\n(\nobj\n);\n\n  \n}\n\n\n  \npublic\n \nObject\n \nremove\n()\n \n{\n\n    \nif\n \n(\nimpl\n.\nnonEmpty\n())\n \n{\n\n      \nremoveCounter\n.\nincrement\n();\n\n      \nreturn\n \nimpl\n.\nremove\n();\n\n    \n}\n \nelse\n \n{\n\n      \nreturn\n \nnull\n;\n\n    \n}\n\n  \n}\n\n\n\n\n\n\nOptionally an amount can be passed in when calling increment. This is useful\nwhen a collection of events happens together. \n\n\n  \npublic\n \nvoid\n \ninsertAll\n(\nCollection\nObject\n \nobjs\n)\n \n{\n\n    \ninsertCounter\n.\nincrement\n(\nobjs\n.\nsize\n());\n\n    \nimpl\n.\ninsertAll\n(\nobjs\n);\n\n  \n}\n\n\n}", 
            "title": "Counters"
        }, 
        {
            "location": "/intro/counter/#counters", 
            "text": "A counter is used to measure the rate at which some event is occurring.\nConsider a simple queue, counters would be used to measure things like the\nrate at which items are being inserted and removed.   Counters are created using the registry which will be setup as part of\napplication initialization. For example:  public   class   Queue   { \n\n   private   final   Counter   insertCounter ; \n   private   final   Counter   removeCounter ; \n   private   final   QueueImpl   impl ; \n\n   @Inject \n   public   Queue ( Registry   registry )   { \n     insertCounter   =   registry . counter ( queue.insert ); \n     removeCounter   =   registry . counter ( queue.remove ); \n     impl   =   new   QueueImpl (); \n   }   Then call increment when an event occurs:     public   void   insert ( Object   obj )   { \n     insertCounter . increment (); \n     impl . insert ( obj ); \n   } \n\n   public   Object   remove ()   { \n     if   ( impl . nonEmpty ())   { \n       removeCounter . increment (); \n       return   impl . remove (); \n     }   else   { \n       return   null ; \n     } \n   }   Optionally an amount can be passed in when calling increment. This is useful\nwhen a collection of events happens together.      public   void   insertAll ( Collection Object   objs )   { \n     insertCounter . increment ( objs . size ()); \n     impl . insertAll ( objs ); \n   }  }", 
            "title": "Counters"
        }, 
        {
            "location": "/intro/timer/", 
            "text": "Timers\n\n\nA timer is used to measure how long some event is taking. Two types of timers\nare supported:\n\n\n\n\nTimer\n: for frequent short duration events.\n\n\nLongTaskTimer\n: for long running tasks.\n\n\n\n\nThe long duration timer is setup so that you can track the time while an\nevent being measured is still running. A regular timer just records the\nduration and has no information until the task is complete.\n\n\nAs an example, consider a chart showing request latency to a typical web\nserver. The expectation is many short requests so the timer will be getting\nupdated many times per second.\n\n\n\n\nNow consider a background process to refresh metadata from a data store. For\nexample, Edda caches AWS resources such as instances, volumes, auto-scaling\ngroups etc. Normally all data can be refreshed in a few minutes. If the AWS\nservices are having problems it can take much longer. A long duration timer\ncan be used to track the overall time for refreshing the metadata.\n\n\nThe charts below show max latency for the refresh using a regular timer and\na long task timer. Regular timer, note that the y-axis is using a logarithmic\nscale:\n\n\n\n\nLong task timer:\n\n\n\n\nTimer\n\n\nTo get started create an instance using the registry:\n\n\npublic\n \nclass\n \nServer\n \n{\n\n\n  \nprivate\n \nfinal\n \nRegistry\n \nregistry\n;\n\n  \nprivate\n \nfinal\n \nTimer\n \nrequestLatency\n;\n\n\n  \n@Inject\n\n  \npublic\n \nServer\n(\nRegistry\n \nregistry\n)\n \n{\n\n    \nthis\n.\nregistry\n \n=\n \nregistry\n;\n\n    \nrequestLatency\n \n=\n \nregistry\n.\ntimer\n(\nserver.requestLatency\n);\n\n  \n}\n\n\n\n\n\n\nThen wrap the call you need to measure, preferably using a lambda:\n\n\n  \npublic\n \nResponse\n \nhandle\n(\nRequest\n \nrequest\n)\n \n{\n\n    \nreturn\n \nrequestLatency\n.\nrecord\n(()\n \n-\n \nhandleImpl\n(\nrequest\n));\n\n  \n}\n\n\n\n\n\n\nThe lambda variants will handle exceptions for you and ensure the\nrecord happens as part of a finally block using the monotonic time.\nIt could also have been done more explicitly like:\n\n\n  \npublic\n \nResponse\n \nhandle\n(\nRequest\n \nrequest\n)\n \n{\n\n    \nfinal\n \nlong\n \nstart\n \n=\n \nregistry\n.\nclock\n().\nmonotonicTime\n();\n\n    \ntry\n \n{\n\n      \nreturn\n \nhandleImpl\n(\nrequest\n);\n\n    \n}\n \nfinally\n \n{\n\n      \nfinal\n \nlong\n \nend\n \n=\n \nregistry\n.\nclock\n().\nmonotonicTime\n();\n\n      \nrequestLatency\n.\nrecord\n(\nend\n \n-\n \nstart\n,\n \nTimeUnit\n.\nNANOSECONDS\n);\n\n    \n}\n\n  \n}\n\n\n\n\n\n\nThis example uses the clock from the registry which can be useful for\ntesting if you need to control the timing. In actual usage it will typically\nget mapped to the system clock. It is recommended to use a monotonically\nincreasing source for measuring the times to avoid occasionally having bogus\nmeasurements due to time adjustments. For more information see the\n\nClock documentation\n.\n\n\nLongTaskTimer\n\n\nTo get started create an instance using the registry:\n\n\npublic\n \nclass\n \nMetadataService\n \n{\n\n\n  \nprivate\n \nfinal\n \nLongTaskTimer\n \nmetadataRefresh\n;\n\n\n  \n@Inject\n\n  \npublic\n \nMetadataService\n(\nRegistry\n \nregistry\n)\n \n{\n\n    \nmetadataRefresh\n \n=\n \nregistry\n.\nlongTaskTimer\n(\nmetadata.refreshDuration\n);\n\n    \n// setup background thread to call refresh()\n\n  \n}\n\n\n  \nprivate\n \nvoid\n \nrefresh\n()\n \n{\n\n    \nfinal\n \nint\n \nid\n \n=\n \nmetadataRefresh\n.\nstart\n();\n\n    \ntry\n \n{\n\n      \nrefreshImpl\n();\n\n    \n}\n \nfinally\n \n{\n\n      \nmetadataRefresh\n.\nstop\n(\nid\n);\n\n    \n}\n\n  \n}\n\n\n\n\n\n\nThe id is used to keep track of a particular task being measured by the timer.\nIt must be stopped using the provided id. Note that unlike a regular timer\nthat does not do anything until the final duration is recorded, a long duration\ntimer will report as two gauges:\n\n\n\n\nduration\n: total duration spent within all currently running tasks.\n\n\nactiveTasks\n: number of currently running tasks.\n\n\n\n\nThis means that you can see what is happening while the task is running, but\nyou need to keep in mind:\n\n\n\n\nThe id is fixed before the task begins. There is no way to change tags based\n  on the run, e.g., update a different timer if an exception is thrown.\n\n\nBeing a guage it is inappropriate for short tasks. In particular, gauges are\n  sampled and if it is not sampled during the execution or the sampling period\n  is a significant subset of the expected duration, then the duration value\n  will not be meaningful.\n\n\n\n\nLike a regular timer, the duration timer also supports using a lambda to\nsimplify the common case:\n\n\n  \nprivate\n \nvoid\n \nrefresh\n()\n \n{\n\n    \nmetadataRefresh\n.\nrecord\n(\nthis\n::\nrefreshImpl\n);\n\n  \n}", 
            "title": "Timers"
        }, 
        {
            "location": "/intro/timer/#timers", 
            "text": "A timer is used to measure how long some event is taking. Two types of timers\nare supported:   Timer : for frequent short duration events.  LongTaskTimer : for long running tasks.   The long duration timer is setup so that you can track the time while an\nevent being measured is still running. A regular timer just records the\nduration and has no information until the task is complete.  As an example, consider a chart showing request latency to a typical web\nserver. The expectation is many short requests so the timer will be getting\nupdated many times per second.   Now consider a background process to refresh metadata from a data store. For\nexample, Edda caches AWS resources such as instances, volumes, auto-scaling\ngroups etc. Normally all data can be refreshed in a few minutes. If the AWS\nservices are having problems it can take much longer. A long duration timer\ncan be used to track the overall time for refreshing the metadata.  The charts below show max latency for the refresh using a regular timer and\na long task timer. Regular timer, note that the y-axis is using a logarithmic\nscale:   Long task timer:", 
            "title": "Timers"
        }, 
        {
            "location": "/intro/timer/#timer", 
            "text": "To get started create an instance using the registry:  public   class   Server   { \n\n   private   final   Registry   registry ; \n   private   final   Timer   requestLatency ; \n\n   @Inject \n   public   Server ( Registry   registry )   { \n     this . registry   =   registry ; \n     requestLatency   =   registry . timer ( server.requestLatency ); \n   }   Then wrap the call you need to measure, preferably using a lambda:     public   Response   handle ( Request   request )   { \n     return   requestLatency . record (()   -   handleImpl ( request )); \n   }   The lambda variants will handle exceptions for you and ensure the\nrecord happens as part of a finally block using the monotonic time.\nIt could also have been done more explicitly like:     public   Response   handle ( Request   request )   { \n     final   long   start   =   registry . clock (). monotonicTime (); \n     try   { \n       return   handleImpl ( request ); \n     }   finally   { \n       final   long   end   =   registry . clock (). monotonicTime (); \n       requestLatency . record ( end   -   start ,   TimeUnit . NANOSECONDS ); \n     } \n   }   This example uses the clock from the registry which can be useful for\ntesting if you need to control the timing. In actual usage it will typically\nget mapped to the system clock. It is recommended to use a monotonically\nincreasing source for measuring the times to avoid occasionally having bogus\nmeasurements due to time adjustments. For more information see the Clock documentation .", 
            "title": "Timer"
        }, 
        {
            "location": "/intro/timer/#longtasktimer", 
            "text": "To get started create an instance using the registry:  public   class   MetadataService   { \n\n   private   final   LongTaskTimer   metadataRefresh ; \n\n   @Inject \n   public   MetadataService ( Registry   registry )   { \n     metadataRefresh   =   registry . longTaskTimer ( metadata.refreshDuration ); \n     // setup background thread to call refresh() \n   } \n\n   private   void   refresh ()   { \n     final   int   id   =   metadataRefresh . start (); \n     try   { \n       refreshImpl (); \n     }   finally   { \n       metadataRefresh . stop ( id ); \n     } \n   }   The id is used to keep track of a particular task being measured by the timer.\nIt must be stopped using the provided id. Note that unlike a regular timer\nthat does not do anything until the final duration is recorded, a long duration\ntimer will report as two gauges:   duration : total duration spent within all currently running tasks.  activeTasks : number of currently running tasks.   This means that you can see what is happening while the task is running, but\nyou need to keep in mind:   The id is fixed before the task begins. There is no way to change tags based\n  on the run, e.g., update a different timer if an exception is thrown.  Being a guage it is inappropriate for short tasks. In particular, gauges are\n  sampled and if it is not sampled during the execution or the sampling period\n  is a significant subset of the expected duration, then the duration value\n  will not be meaningful.   Like a regular timer, the duration timer also supports using a lambda to\nsimplify the common case:     private   void   refresh ()   { \n     metadataRefresh . record ( this :: refreshImpl ); \n   }", 
            "title": "LongTaskTimer"
        }, 
        {
            "location": "/intro/gauge/", 
            "text": "Gauges\n\n\nA gauge is a value that is sampled at some point in time. Typical examples\nfor gauges would be the size of a queue or number of threads in the running\nstate. Since gauges are not updated inline when a state change occurs, there is\nno information about what might have occurred between samples.\n\n\nConsider monitoring the behavior of a queue of tasks. If the data is being\ncollected once a minute, then a gauge for the size will show the size when\nit was sampled. The size may have been much higher or lower at some point\nduring interval, but that is not known.\n\n\nPolled Gauges\n\n\nThe most common use of gauges is by registering a hook with Spectator so that\nit will poll the values in the background. This is done by using the \nPolledMeter\n\nhelper class.\n\n\nA polled gauge is registered by passing in an id, a reference to the object, and\na function to get or compute a numeric value based on the object. Note that\na gauge should only be registered once, not on each update. Consider this\nexample of a web server tracking the number of connections:\n\n\nclass\n \nHttpServer\n \n{\n\n  \n// Tracks the number of current connections to the server\n\n  \nprivate\n \nAtomicInteger\n \nnumConnections\n;\n\n\n  \npublic\n \nHttpServer\n(\nRegistry\n \nregistry\n)\n \n{\n\n    \nnumConnections\n \n=\n \nPolledMeter\n.\nusing\n(\nregistry\n)\n\n      \n.\nwithName\n(\nserver.numConnections\n)\n\n      \n.\nmonitorValue\n(\nnew\n \nAtomicInteger\n(\n0\n));\n\n  \n}\n\n\n  \npublic\n \nvoid\n \nonConnectionCreated\n()\n \n{\n\n    \nnumConnections\n.\nincrementAndGet\n();\n\n    \n...\n\n  \n}\n\n\n  \npublic\n \nvoid\n \nonConnectionClosed\n()\n \n{\n\n    \nnumConnections\n.\ndecrementAndGet\n();\n\n    \n...\n\n  \n}\n\n\n  \n...\n\n\n}\n\n\n\n\n\n\nThe spectator registry will keep a weak reference to the object. If the object is\ngarbage collected, then it will automatically drop the registration. In the example\nabove, the registry will have a weak reference to \nnumConnections\n and the server\ninstance will have a strong reference to \nnumConnections\n. If the server instance\ngoes away, then the gauge will as well.\n\n\nWhen multiple gauges are registered with the same id the reported value will\nbe the sum of the matches. For example, if multiple instances of the \nHttpServer\n\nclass were created on different ports, then the value \nserver.numConnections\n\nwould be the total number of connections across all server instances. If a different\nbehavior is desired, then ensure your usage does not perform multiple registrations.\n\n\nThere are several different ways to register a gauge:\n\n\nUsing Number\n\n\nA gauge can also be created based on an implementation of Number. Note the number\nimplementation should be thread safe. For example:\n\n\nAtomicInteger\n \nsize\n \n=\n \nnew\n \nAtomicInteger\n();\n\n\nPolledMeter\n.\nusing\n(\nregistry\n)\n\n  \n.\nwithName\n(\nqueue.size\n)\n\n  \n.\nmonitorValue\n(\nsize\n);\n\n\n\n\n\n\nThe call will return the Number so the registration can be inline on the\nassignment:\n\n\nAtomicInteger\n \nsize\n \n=\n \nPolledMeter\n.\nusing\n(\nregistry\n)\n\n  \n.\nwithName\n(\nqueue.size\n)\n\n  \n.\nmonitorValue\n(\nsize\n);\n\n\n\n\n\n\nUpdates to the value are preformed by updating the number instance directly.\n\n\nUsing Lambda\n\n\nSpecify a lambda that takes the object as parameter.\n\n\npublic\n \nclass\n \nQueue\n \n{\n\n\n  \n@Inject\n\n  \npublic\n \nQueue\n(\nRegistry\n \nregistry\n)\n \n{\n\n    \nPolledMeter\n.\nusing\n(\nregistry\n)\n\n      \n.\nwithName\n(\nqueue.size\n)\n\n      \n.\nmonitorValue\n(\nthis\n,\n \nQueue\n::\nsize\n);\n\n  \n}\n\n\n  \n...\n\n\n}\n\n\n\n\n\n\n\n\nWarning\n\n\nBe careful to avoid creating a reference to the object in the\nlambda. It will prevent garbage collection and can lead to a memory leak\nin the application. For example, by calling size without using the passed\nin object there will be a reference to \nthis\n:\n\n\nPolledMeter.using(registry).withName(\"queue.size\").monitorValue(this, obj -\n size());\n\n\n\n\nCollection Sizes\n\n\nFor classes that implement \nCollection\n or \nMap\n there are helpers:\n\n\nQueue\n \nqueue\n \n=\n \nnew\n \nLinkedBlockingQueue\n();\n\n\nPolledMeter\n.\nusing\n(\nregistry\n)\n\n  \n.\nwithName\n(\nqueue.size\n)\n\n  \n.\nmonitorSize\n(\nqueue\n);\n\n\n\nMap\nString\n,\n \nString\n \ncache\n \n=\n \nnew\n \nConcurrentMap\n();\n\n\nPolledMeter\n.\nusing\n(\nregistry\n)\n\n  \n.\nwithName\n(\ncache.size\n)\n\n  \n.\nmonitorSize\n(\ncache\n);\n\n\n\n\n\n\nMonotonic Counters\n\n\nA common technique used by some libraries is to expose a monotonically increasing\ncounter that represents the number of events since the system was initialized. An\nexample of that in the JDK is \nThreadPoolExecutor.getCompletedTaskCount()\n which\nreturns the number of completed tasks on the thread pool.\n\n\nFor sources like this the \nmonitorMonotonicCounter\n method can be used:\n\n\n// For an implementation of Number\n\n\nLongAdder\n \ntasks\n \n=\n \nnew\n \nLongAdder\n();\n\n\nPolledMeter\n.\nusing\n(\nregistry\n)\n\n  \n.\nwithName\n(\npool.completedTasks\n)\n\n  \n.\nmonitorMonotonicCounter\n(\ntasks\n);\n\n\n\n// Or using a lambda\n\n\nThreadPoolExecutor\n \nexecutor\n \n=\n \n...\n\n\nPolledMeter\n.\nusing\n(\nregistry\n)\n\n  \n.\nwithName\n(\npool.completedTasks\n)\n\n  \n.\nmonitorMonotonicCounter\n(\nexecutor\n,\n \nThreadPoolExecutor\n::\ngetCompletedTaskCount\n);\n\n\n\n\n\n\nFor thread pools specifically, there are better options for getting standard metrics.\nSee the docs for the \nThread Pools extension\n for more\ninformation.\n\n\nActive Gauges\n\n\nGauges can also be set directly by the user. In this mode the user is responsible for\nregularly updating the value of the gauge by calling set. Looking at the HttpServer\nexample, with an active gauge it would look like:\n\n\nclass\n \nHttpServer\n \n{\n\n  \n// Tracks the number of current connections to the server\n\n  \nprivate\n \nAtomicInteger\n \nnumConnections\n;\n\n  \nprivate\n \nGauge\n \ngauge\n;\n\n\n  \npublic\n \nHttpServer\n(\nRegistry\n \nregistry\n)\n \n{\n\n    \nnumConnections\n \n=\n \nnew\n \nAtomicInteger\n();\n\n    \ngauge\n \n=\n \nregistry\n.\ngauge\n(\nserver.numConnections\n);\n\n    \ngauge\n.\nset\n(\nnumConnections\n.\nget\n());\n\n  \n}\n\n\n  \npublic\n \nvoid\n \nonConnectionCreated\n()\n \n{\n\n    \nnumConnections\n.\nincrementAndGet\n();\n\n    \ngauge\n.\nset\n(\nnumConnections\n.\nget\n());\n\n    \n...\n\n  \n}\n\n\n  \npublic\n \nvoid\n \nonConnectionClosed\n()\n \n{\n\n    \nnumConnections\n.\ndecrementAndGet\n();\n\n    \ngauge\n.\nset\n(\nnumConnections\n.\nget\n());\n\n    \n...\n\n  \n}\n\n\n  \n...\n\n\n}", 
            "title": "Gauges"
        }, 
        {
            "location": "/intro/gauge/#gauges", 
            "text": "A gauge is a value that is sampled at some point in time. Typical examples\nfor gauges would be the size of a queue or number of threads in the running\nstate. Since gauges are not updated inline when a state change occurs, there is\nno information about what might have occurred between samples.  Consider monitoring the behavior of a queue of tasks. If the data is being\ncollected once a minute, then a gauge for the size will show the size when\nit was sampled. The size may have been much higher or lower at some point\nduring interval, but that is not known.", 
            "title": "Gauges"
        }, 
        {
            "location": "/intro/gauge/#polled-gauges", 
            "text": "The most common use of gauges is by registering a hook with Spectator so that\nit will poll the values in the background. This is done by using the  PolledMeter \nhelper class.  A polled gauge is registered by passing in an id, a reference to the object, and\na function to get or compute a numeric value based on the object. Note that\na gauge should only be registered once, not on each update. Consider this\nexample of a web server tracking the number of connections:  class   HttpServer   { \n   // Tracks the number of current connections to the server \n   private   AtomicInteger   numConnections ; \n\n   public   HttpServer ( Registry   registry )   { \n     numConnections   =   PolledMeter . using ( registry ) \n       . withName ( server.numConnections ) \n       . monitorValue ( new   AtomicInteger ( 0 )); \n   } \n\n   public   void   onConnectionCreated ()   { \n     numConnections . incrementAndGet (); \n     ... \n   } \n\n   public   void   onConnectionClosed ()   { \n     numConnections . decrementAndGet (); \n     ... \n   } \n\n   ...  }   The spectator registry will keep a weak reference to the object. If the object is\ngarbage collected, then it will automatically drop the registration. In the example\nabove, the registry will have a weak reference to  numConnections  and the server\ninstance will have a strong reference to  numConnections . If the server instance\ngoes away, then the gauge will as well.  When multiple gauges are registered with the same id the reported value will\nbe the sum of the matches. For example, if multiple instances of the  HttpServer \nclass were created on different ports, then the value  server.numConnections \nwould be the total number of connections across all server instances. If a different\nbehavior is desired, then ensure your usage does not perform multiple registrations.  There are several different ways to register a gauge:", 
            "title": "Polled Gauges"
        }, 
        {
            "location": "/intro/gauge/#using-number", 
            "text": "A gauge can also be created based on an implementation of Number. Note the number\nimplementation should be thread safe. For example:  AtomicInteger   size   =   new   AtomicInteger ();  PolledMeter . using ( registry ) \n   . withName ( queue.size ) \n   . monitorValue ( size );   The call will return the Number so the registration can be inline on the\nassignment:  AtomicInteger   size   =   PolledMeter . using ( registry ) \n   . withName ( queue.size ) \n   . monitorValue ( size );   Updates to the value are preformed by updating the number instance directly.", 
            "title": "Using Number"
        }, 
        {
            "location": "/intro/gauge/#using-lambda", 
            "text": "Specify a lambda that takes the object as parameter.  public   class   Queue   { \n\n   @Inject \n   public   Queue ( Registry   registry )   { \n     PolledMeter . using ( registry ) \n       . withName ( queue.size ) \n       . monitorValue ( this ,   Queue :: size ); \n   } \n\n   ...  }    Warning  Be careful to avoid creating a reference to the object in the\nlambda. It will prevent garbage collection and can lead to a memory leak\nin the application. For example, by calling size without using the passed\nin object there will be a reference to  this :  PolledMeter.using(registry).withName(\"queue.size\").monitorValue(this, obj -  size());", 
            "title": "Using Lambda"
        }, 
        {
            "location": "/intro/gauge/#collection-sizes", 
            "text": "For classes that implement  Collection  or  Map  there are helpers:  Queue   queue   =   new   LinkedBlockingQueue ();  PolledMeter . using ( registry ) \n   . withName ( queue.size ) \n   . monitorSize ( queue );  Map String ,   String   cache   =   new   ConcurrentMap ();  PolledMeter . using ( registry ) \n   . withName ( cache.size ) \n   . monitorSize ( cache );", 
            "title": "Collection Sizes"
        }, 
        {
            "location": "/intro/gauge/#monotonic-counters", 
            "text": "A common technique used by some libraries is to expose a monotonically increasing\ncounter that represents the number of events since the system was initialized. An\nexample of that in the JDK is  ThreadPoolExecutor.getCompletedTaskCount()  which\nreturns the number of completed tasks on the thread pool.  For sources like this the  monitorMonotonicCounter  method can be used:  // For an implementation of Number  LongAdder   tasks   =   new   LongAdder ();  PolledMeter . using ( registry ) \n   . withName ( pool.completedTasks ) \n   . monitorMonotonicCounter ( tasks );  // Or using a lambda  ThreadPoolExecutor   executor   =   ...  PolledMeter . using ( registry ) \n   . withName ( pool.completedTasks ) \n   . monitorMonotonicCounter ( executor ,   ThreadPoolExecutor :: getCompletedTaskCount );   For thread pools specifically, there are better options for getting standard metrics.\nSee the docs for the  Thread Pools extension  for more\ninformation.", 
            "title": "Monotonic Counters"
        }, 
        {
            "location": "/intro/gauge/#active-gauges", 
            "text": "Gauges can also be set directly by the user. In this mode the user is responsible for\nregularly updating the value of the gauge by calling set. Looking at the HttpServer\nexample, with an active gauge it would look like:  class   HttpServer   { \n   // Tracks the number of current connections to the server \n   private   AtomicInteger   numConnections ; \n   private   Gauge   gauge ; \n\n   public   HttpServer ( Registry   registry )   { \n     numConnections   =   new   AtomicInteger (); \n     gauge   =   registry . gauge ( server.numConnections ); \n     gauge . set ( numConnections . get ()); \n   } \n\n   public   void   onConnectionCreated ()   { \n     numConnections . incrementAndGet (); \n     gauge . set ( numConnections . get ()); \n     ... \n   } \n\n   public   void   onConnectionClosed ()   { \n     numConnections . decrementAndGet (); \n     gauge . set ( numConnections . get ()); \n     ... \n   } \n\n   ...  }", 
            "title": "Active Gauges"
        }, 
        {
            "location": "/intro/dist-summary/", 
            "text": "Distribution Summaries\n\n\nA distribution summary is used to track the distribution of events. It is\nsimilar to a timer, but more general in that the size does not have to be\na period of time. For example, a distribution summary could be used to measure\nthe payload sizes of requests hitting a server.\n\n\nIt is recommended to always use base units when recording the data. So if\nmeasuring the payload size use bytes, not kilobytes or some other unit.\n\n\nDistribution summaries are created using the registry which will be setup as\npart of application initialization. For example:\n\n\npublic\n \nclass\n \nServer\n \n{\n\n\n  \nprivate\n \nfinal\n \nDistributionSummary\n \nrequestSize\n;\n\n\n  \n@Inject\n\n  \npublic\n \nServer\n(\nRegistry\n \nregistry\n)\n \n{\n\n    \nrequestSize\n \n=\n \nregistry\n.\ndistributionSummary\n(\nserver.requestSize\n);\n\n  \n}\n\n\n\n\n\n\nThen call record when an event occurs:\n\n\n  \npublic\n \nResponse\n \nhandle\n(\nRequest\n \nrequest\n)\n \n{\n\n    \nrequestSize\n.\nrecord\n(\nrequest\n.\nsizeInBytes\n());\n\n  \n}\n\n\n}", 
            "title": "Distribution Summaries"
        }, 
        {
            "location": "/intro/dist-summary/#distribution-summaries", 
            "text": "A distribution summary is used to track the distribution of events. It is\nsimilar to a timer, but more general in that the size does not have to be\na period of time. For example, a distribution summary could be used to measure\nthe payload sizes of requests hitting a server.  It is recommended to always use base units when recording the data. So if\nmeasuring the payload size use bytes, not kilobytes or some other unit.  Distribution summaries are created using the registry which will be setup as\npart of application initialization. For example:  public   class   Server   { \n\n   private   final   DistributionSummary   requestSize ; \n\n   @Inject \n   public   Server ( Registry   registry )   { \n     requestSize   =   registry . distributionSummary ( server.requestSize ); \n   }   Then call record when an event occurs:     public   Response   handle ( Request   request )   { \n     requestSize . record ( request . sizeInBytes ()); \n   }  }", 
            "title": "Distribution Summaries"
        }, 
        {
            "location": "/intro/clock/", 
            "text": "Clock\n\n\nWhen taking measurements or working with timers it is recommended to use the\n\nclock\n\ninterface. It provides two methods for measuring time:\n\n\nWall Time\n\n\nThis is what most users think of for time. It can be used to get the current\ntime like what you would see on a wall clock. In most cases when not running\nin tests this will call \nSystem.currentTimeMillis()\n.\n\n\nNote that the values returned by this method may not be monontonically increasing.\nJust like a clock on your wall, this value can go back in time or jump forward\nat unpredictable intervals if someone sets the time. On many systems\n\nntpd\n will be constantly keeping the time\nsynced up with an authoritative source.\n\n\nWith spectator, the clock is typically accessed via the \nregstry\n.\nExample of usage:\n\n\n// Current time in milliseconds since the epoch\n\n\nlong\n \ncurrentTime\n \n=\n \nregistry\n.\nclock\n().\nwallTime\n();\n\n\n\n\n\n\nMonotonic Time\n\n\nWhile it is good in general for the wall clock to show the correct time, the\nunpredictable changes mean it is not a good choice for measuring how long an\noperation took. Consider a simple example of measuring request latency on a\nserver:\n\n\nlong\n \nstart\n \n=\n \nregistry\n.\nclock\n().\nwallTime\n();\n\n\nhandleRequest\n(\nrequest\n,\n \nresponse\n);\n\n\nlong\n \nend\n \n=\n \nregistry\n.\nclock\n().\nwallTime\n();\n\n\nreqLatencyTimer\n.\nrecord\n(\nend\n \n-\n \nstart\n,\n \nTimeUnit\n.\nMILLISECONDS\n);\n\n\n\n\n\n\nIf ntp fixes the server time between \nstart\n and \nend\n, then the recorded\nlatency will be wrong. Spectator will protect against obviously wrong\nmeasurements like negative latencies by dropping those values when they are\nrecorded. However, the change could incorrectly shorten or lengthen the\nmeasured latency.\n\n\nThe clock interface also provides access to a monotonic source that is\nonly useful for measuring elapsed time, for example:\n\n\nlong\n \nstart\n \n=\n \nregistry\n.\nclock\n().\nmonotonicTime\n();\n\n\nhandleRequest\n(\nrequest\n,\n \nresponse\n);\n\n\nlong\n \nend\n \n=\n \nregistry\n.\nclock\n().\nmonotonicTime\n();\n\n\nreqLatencyTimer\n.\nrecord\n(\nend\n \n-\n \nstart\n,\n \nTimeUnit\n.\nNANOSECONDS\n);\n\n\n\n\n\n\nIn most cases this will map to\n\nSystem.nanoTime()\n.\nNote the actual value returned is not meaningful unless compared with\nanother sample to get a delta.\n\n\nManual Clock\n\n\nIf timing code is written to the clock interface, then alternative implemenations\ncan be plugged in. For test cases it is common to use\n\nManualClock\n\nso that tests can be reliable and fast without having to rely on hacks like sleep or\nassuming something will run in less than a certain amount of time. \n\n\nManualClock\n \nclock\n \n=\n \nnew\n \nManualClock\n();\n\n\nRegistry\n \nregistry\n \n=\n \nnew\n \nDefaultRegistry\n(\nclock\n);\n\n\n\nTimer\n \ntimer\n \n=\n \nregistry\n.\ntimer\n(\ntest\n);\n\n\ntimer\n.\nrecord\n(()\n \n-\n \n{\n\n  \ndoSomething\n();\n\n  \nclock\n.\nsetMonotonicTime\n(\n42L\n);\n\n\n});\n\n\n\nAssert\n.\nassertEquals\n(\ntimer\n.\ntotalTime\n(),\n \n42L\n);", 
            "title": "Clock"
        }, 
        {
            "location": "/intro/clock/#clock", 
            "text": "When taking measurements or working with timers it is recommended to use the clock \ninterface. It provides two methods for measuring time:", 
            "title": "Clock"
        }, 
        {
            "location": "/intro/clock/#wall-time", 
            "text": "This is what most users think of for time. It can be used to get the current\ntime like what you would see on a wall clock. In most cases when not running\nin tests this will call  System.currentTimeMillis() .  Note that the values returned by this method may not be monontonically increasing.\nJust like a clock on your wall, this value can go back in time or jump forward\nat unpredictable intervals if someone sets the time. On many systems ntpd  will be constantly keeping the time\nsynced up with an authoritative source.  With spectator, the clock is typically accessed via the  regstry .\nExample of usage:  // Current time in milliseconds since the epoch  long   currentTime   =   registry . clock (). wallTime ();", 
            "title": "Wall Time"
        }, 
        {
            "location": "/intro/clock/#monotonic-time", 
            "text": "While it is good in general for the wall clock to show the correct time, the\nunpredictable changes mean it is not a good choice for measuring how long an\noperation took. Consider a simple example of measuring request latency on a\nserver:  long   start   =   registry . clock (). wallTime ();  handleRequest ( request ,   response );  long   end   =   registry . clock (). wallTime ();  reqLatencyTimer . record ( end   -   start ,   TimeUnit . MILLISECONDS );   If ntp fixes the server time between  start  and  end , then the recorded\nlatency will be wrong. Spectator will protect against obviously wrong\nmeasurements like negative latencies by dropping those values when they are\nrecorded. However, the change could incorrectly shorten or lengthen the\nmeasured latency.  The clock interface also provides access to a monotonic source that is\nonly useful for measuring elapsed time, for example:  long   start   =   registry . clock (). monotonicTime ();  handleRequest ( request ,   response );  long   end   =   registry . clock (). monotonicTime ();  reqLatencyTimer . record ( end   -   start ,   TimeUnit . NANOSECONDS );   In most cases this will map to System.nanoTime() .\nNote the actual value returned is not meaningful unless compared with\nanother sample to get a delta.", 
            "title": "Monotonic Time"
        }, 
        {
            "location": "/intro/clock/#manual-clock", 
            "text": "If timing code is written to the clock interface, then alternative implemenations\ncan be plugged in. For test cases it is common to use ManualClock \nso that tests can be reliable and fast without having to rely on hacks like sleep or\nassuming something will run in less than a certain amount of time.   ManualClock   clock   =   new   ManualClock ();  Registry   registry   =   new   DefaultRegistry ( clock );  Timer   timer   =   registry . timer ( test );  timer . record (()   -   { \n   doSomething (); \n   clock . setMonotonicTime ( 42L );  });  Assert . assertEquals ( timer . totalTime (),   42L );", 
            "title": "Manual Clock"
        }, 
        {
            "location": "/intro/conventions/", 
            "text": "Quick summary:\n\n\n\n\nNames\n\n\nDescribe the measurement being collected\n\n\nUse camel case\n\n\nStatic\n\n\nSuccinct\n\n\n\n\n\n\nTags\n\n\nShould be used for dimensional drill-down\n\n\nBe careful about combinatorial explosion\n\n\nTag keys should be static\n\n\nUse \nid\n to distinguish between instances\n\n\n\n\n\n\nUse base units\n\n\n\n\nNames\n\n\nDescribe the measurement\n\n\nUse camel case\n\n\nThe main goal here is to promote consistency which makes it easier for users. The choice of\nstyle is somewhat arbitrary, camel case was chosen because:\n\n\n\n\nUsed by snmp\n\n\nUsed by java\n\n\nIt was the most common in use at Netflix when this guideline was added\n\n\n\n\nThe exception to this rule is where there is an established common case. For example with\nAmazon regions it is preferred to use us-east-1 rather than usEast1 as it is the more common\nform.\n\n\nStatic\n\n\nThere shouldn't be any dynamic content that goes into a metric name. Metric names and\nassociated tag keys are how users will interact with the data being produced. \n\n\nSuccinct\n\n\nLong names should be avoided. \n\n\nTags\n\n\nHistorically tags have been used to play one of two roles:\n\n\n\n\nDimensions\n: dimensions are the primary use and it allows the data to be sliced and diced so\n  it is possible to drill down into the data.\n\n\nNamespace\n: similar to packages in Java in this mode it would be used to group related data.\n  This type of usage is discouraged.   \n\n\n\n\nAs a general rule it should be possible to use the name as a pivot. This means that if\njust the name is selected, then the user can drill down using other dimensions and be\nable to reason about the value being shown. \n\n\nAs a concrete example, suppose we have two metrics:\n\n\n\n\nThe number of threads currently in a thread pool.\n\n\nThe number of rows in a database table.\n\n\n\n\nBad approach\n\n\nId\n \npoolSize\n \n=\n \nregistry\n.\ncreateId\n(\nsize\n)\n\n  \n.\nwithTag\n(\nclass\n,\n \nThreadPool\n)\n\n  \n.\nwithTag\n(\nid\n,\n \nserver-requests\n);\n\n\n\nId\n \npoolSize\n \n=\n \nregistry\n.\ncreateId\n(\nsize\n)\n\n  \n.\nwithTag\n(\nclass\n,\n \nDatabase\n)\n\n  \n.\nwithTag\n(\ntable\n,\n \nusers\n);\n  \n\n\n\n\n\nIn this approach, if I select the name, \nsize\n, it will match both the version for \nThreadPool and Database classes. So you would get a value that is the an aggregate of the number\nof threads and the number of items in a database. \n\n\nRecommended\n\n\nId\n \npoolSize\n \n=\n \nregistry\n.\ncreateId\n(\nthreadpool.size\n)\n\n  \n.\nwithTag\n(\nid\n,\n \nserver-requests\n);\n\n\n\nId\n \npoolSize\n \n=\n \nregistry\n.\ncreateId\n(\ndb.size\n)\n\n  \n.\nwithTag\n(\ntable\n,\n \nusers\n);\n  \n\n\n\n\n\nThis variant provides enough context so that if just the name is selected the value can\nbe reasoned about and is at least potentially meaningful. For example if I select\n\nthreadpool.size\n I can see the total number of threads in all pools. Then I can group by or\nselect an \nid\n to drill down further.\n\n\nUse base units\n\n\nKeep measurements in base units where possible. For example I would rather have all timers\nin seconds, disk sizes should be bytes, or network rates should be bytes/second. The reason\nis that for my uses this usually means the unit is obvious from the name. It also means the\nSI prefix shown on the graph images make more sense, e.g. 1k is 1 kilobyte not 1 kilo-megabyte.", 
            "title": "Naming Conventions"
        }, 
        {
            "location": "/intro/conventions/#names", 
            "text": "", 
            "title": "Names"
        }, 
        {
            "location": "/intro/conventions/#describe-the-measurement", 
            "text": "", 
            "title": "Describe the measurement"
        }, 
        {
            "location": "/intro/conventions/#use-camel-case", 
            "text": "The main goal here is to promote consistency which makes it easier for users. The choice of\nstyle is somewhat arbitrary, camel case was chosen because:   Used by snmp  Used by java  It was the most common in use at Netflix when this guideline was added   The exception to this rule is where there is an established common case. For example with\nAmazon regions it is preferred to use us-east-1 rather than usEast1 as it is the more common\nform.", 
            "title": "Use camel case"
        }, 
        {
            "location": "/intro/conventions/#static", 
            "text": "There shouldn't be any dynamic content that goes into a metric name. Metric names and\nassociated tag keys are how users will interact with the data being produced.", 
            "title": "Static"
        }, 
        {
            "location": "/intro/conventions/#succinct", 
            "text": "Long names should be avoided.", 
            "title": "Succinct"
        }, 
        {
            "location": "/intro/conventions/#tags", 
            "text": "Historically tags have been used to play one of two roles:   Dimensions : dimensions are the primary use and it allows the data to be sliced and diced so\n  it is possible to drill down into the data.  Namespace : similar to packages in Java in this mode it would be used to group related data.\n  This type of usage is discouraged.      As a general rule it should be possible to use the name as a pivot. This means that if\njust the name is selected, then the user can drill down using other dimensions and be\nable to reason about the value being shown.   As a concrete example, suppose we have two metrics:   The number of threads currently in a thread pool.  The number of rows in a database table.", 
            "title": "Tags"
        }, 
        {
            "location": "/intro/conventions/#bad-approach", 
            "text": "Id   poolSize   =   registry . createId ( size ) \n   . withTag ( class ,   ThreadPool ) \n   . withTag ( id ,   server-requests );  Id   poolSize   =   registry . createId ( size ) \n   . withTag ( class ,   Database ) \n   . withTag ( table ,   users );     In this approach, if I select the name,  size , it will match both the version for \nThreadPool and Database classes. So you would get a value that is the an aggregate of the number\nof threads and the number of items in a database.", 
            "title": "Bad approach"
        }, 
        {
            "location": "/intro/conventions/#recommended", 
            "text": "Id   poolSize   =   registry . createId ( threadpool.size ) \n   . withTag ( id ,   server-requests );  Id   poolSize   =   registry . createId ( db.size ) \n   . withTag ( table ,   users );     This variant provides enough context so that if just the name is selected the value can\nbe reasoned about and is at least potentially meaningful. For example if I select threadpool.size  I can see the total number of threads in all pools. Then I can group by or\nselect an  id  to drill down further.", 
            "title": "Recommended"
        }, 
        {
            "location": "/intro/conventions/#use-base-units", 
            "text": "Keep measurements in base units where possible. For example I would rather have all timers\nin seconds, disk sizes should be bytes, or network rates should be bytes/second. The reason\nis that for my uses this usually means the unit is obvious from the name. It also means the\nSI prefix shown on the graph images make more sense, e.g. 1k is 1 kilobyte not 1 kilo-megabyte.", 
            "title": "Use base units"
        }, 
        {
            "location": "/intro/testing/", 
            "text": "Testing\n\n\nTesting should be relatively straightforward if you are using injection for the registry.\nConsider a sample class:\n\n\npublic\n \nclass\n \nFoo\n \n{\n\n\n  \nprivate\n \nfinal\n \nCounter\n \ncounter\n;\n\n\n  \n@Inject\n\n  \npublic\n \nFoo\n(\nRegistry\n \nregistry\n)\n \n{\n\n    \ncounter\n \n=\n \nregistry\n.\ncounter\n(\nfoo\n);\n\n  \n}\n\n\n  \npublic\n \nvoid\n \ndoSomething\n()\n \n{\n\n    \ncounter\n.\nincrement\n();\n\n  \n}\n\n\n}\n\n\n\n\n\n\nTests will typically want to use an isolated instance of the \nDefaultRegistry\n.\n\n\nSimple Test\n\n\nA basic standalone test class would look something like:\n\n\npublic\n \nclass\n \nFooTest\n \n{\n\n\n  \nprivate\n \nRegistry\n \nregistry\n;\n\n  \nprivate\n \nFoo\n \nfoo\n;\n\n\n  \n@Before\n\n  \npublic\n \nvoid\n \ninit\n()\n \n{\n\n    \nregistry\n \n=\n \nnew\n \nDefaultRegistry\n();\n\n    \nfoo\n \n=\n \nnew\n \nFoo\n(\nregistry\n);\n\n  \n}\n\n\n  \n@Test\n\n  \npublic\n \nvoid\n \ndoSomething\n()\n \n{\n\n    \nfoo\n.\ndoSomething\n();\n\n    \nAssert\n.\nassertEquals\n(\n1\n,\n \nregistry\n.\ncounter\n(\nfoo\n).\ncount\n());\n\n  \n}\n\n\n}\n\n\n\n\n\n\nGuice Test\n\n\nIf using guice, then the \nTestModule\n can be used:\n\n\npublic\n \nclass\n \nFooTest\n \n{\n\n\n  \nprivate\n \nRegistry\n \nregistry\n;\n\n  \nprivate\n \nFoo\n \nfoo\n;\n\n\n  \n@Before\n\n  \npublic\n \nvoid\n \ninit\n()\n \n{\n\n    \nInjector\n \ninjector\n \n=\n \nGuice\n.\ncreateInjector\n(\nnew\n \nTestModule\n());\n\n    \nregistry\n \n=\n \ninjector\n.\ngetInstance\n(\nRegistry\n.\nclass\n);\n\n    \nfoo\n \n=\n \ninjector\n.\ngetInstance\n(\nFoo\n.\nclass\n);\n\n  \n}\n\n\n  \n@Test\n\n  \npublic\n \nvoid\n \ndoSomething\n()\n \n{\n\n    \nfoo\n.\ndoSomething\n();\n\n    \nAssert\n.\nassertEquals\n(\n1\n,\n \nregistry\n.\ncounter\n(\nfoo\n).\ncount\n());\n\n  \n}\n\n\n}\n\n\n\n\n\n\nExceptions\n\n\nBy default, for most user errors Spectator will log a warning rather than throw an exception.\nThe rationale is that users do not often think about instrumentation and logging code causing\nan exception and interrupting the control flow of a program. However, for test cases it is\nrecommended to be more aggressive and learn about problems as early as possible. This can\nbe done by setting a system property:\n\n\nspectator.api.propagateWarnings=true\n\n\n\n\n\nConsider an example:\n\n\nprivate\n \nstatic\n \nfinal\n \nId\n \nRARE_EXCEPTION_ID\n \n=\n \nnull\n;\n\n\n\npublic\n \nvoid\n \ndoSomethingImportant\n()\n \n{\n\n  \ntry\n \n{\n\n    \n...\n \ndo\n \nwork\n \n...\n\n  \n}\n \ncatch\n \n(\nRareException\n \ne\n)\n \n{\n\n    \n// There is a bug in the program, an Id is not allowed to be null. In production we do\n\n    \n// not want it to throw and interrupt the control flow. Instrumentation should gracefully\n\n    \n// degrade.\n\n    \nregistry\n.\ncounter\n(\nRARE_EXCEPTION_ID\n).\nincrement\n();\n\n\n    \n// These statements are important to provide context for operating the system\n\n    \n// and to ensure the app continues to function properly.\n\n    \nLOGGER\n.\nerror\n(\nimportant context for user\n,\n \ne\n);\n\n    \nproperlyHandleException\n(\ne\n);\n\n  \n}\n\n\n}", 
            "title": "Testing"
        }, 
        {
            "location": "/intro/testing/#testing", 
            "text": "Testing should be relatively straightforward if you are using injection for the registry.\nConsider a sample class:  public   class   Foo   { \n\n   private   final   Counter   counter ; \n\n   @Inject \n   public   Foo ( Registry   registry )   { \n     counter   =   registry . counter ( foo ); \n   } \n\n   public   void   doSomething ()   { \n     counter . increment (); \n   }  }   Tests will typically want to use an isolated instance of the  DefaultRegistry .", 
            "title": "Testing"
        }, 
        {
            "location": "/intro/testing/#simple-test", 
            "text": "A basic standalone test class would look something like:  public   class   FooTest   { \n\n   private   Registry   registry ; \n   private   Foo   foo ; \n\n   @Before \n   public   void   init ()   { \n     registry   =   new   DefaultRegistry (); \n     foo   =   new   Foo ( registry ); \n   } \n\n   @Test \n   public   void   doSomething ()   { \n     foo . doSomething (); \n     Assert . assertEquals ( 1 ,   registry . counter ( foo ). count ()); \n   }  }", 
            "title": "Simple Test"
        }, 
        {
            "location": "/intro/testing/#guice-test", 
            "text": "If using guice, then the  TestModule  can be used:  public   class   FooTest   { \n\n   private   Registry   registry ; \n   private   Foo   foo ; \n\n   @Before \n   public   void   init ()   { \n     Injector   injector   =   Guice . createInjector ( new   TestModule ()); \n     registry   =   injector . getInstance ( Registry . class ); \n     foo   =   injector . getInstance ( Foo . class ); \n   } \n\n   @Test \n   public   void   doSomething ()   { \n     foo . doSomething (); \n     Assert . assertEquals ( 1 ,   registry . counter ( foo ). count ()); \n   }  }", 
            "title": "Guice Test"
        }, 
        {
            "location": "/intro/testing/#exceptions", 
            "text": "By default, for most user errors Spectator will log a warning rather than throw an exception.\nThe rationale is that users do not often think about instrumentation and logging code causing\nan exception and interrupting the control flow of a program. However, for test cases it is\nrecommended to be more aggressive and learn about problems as early as possible. This can\nbe done by setting a system property:  spectator.api.propagateWarnings=true  Consider an example:  private   static   final   Id   RARE_EXCEPTION_ID   =   null ;  public   void   doSomethingImportant ()   { \n   try   { \n     ...   do   work   ... \n   }   catch   ( RareException   e )   { \n     // There is a bug in the program, an Id is not allowed to be null. In production we do \n     // not want it to throw and interrupt the control flow. Instrumentation should gracefully \n     // degrade. \n     registry . counter ( RARE_EXCEPTION_ID ). increment (); \n\n     // These statements are important to provide context for operating the system \n     // and to ensure the app continues to function properly. \n     LOGGER . error ( important context for user ,   e ); \n     properlyHandleException ( e ); \n   }  }", 
            "title": "Exceptions"
        }, 
        {
            "location": "/intro/netflix/", 
            "text": "Netflix Integration\n\n\nWhen running at Netflix, use the \natlas-client\n library to enable transferring the\ninstrumented data to \nAtlas\n. See the appropriate\nsection for the type of project you are working on:\n\n\n\n\nLibraries\n\n\nApplications\n, specifically standalone apps using guice or governator directly.\n\n\nBase Server\n\n\n\n\nLibraries\n\n\nFor libraries, the only dependency that should be needed is:\n\n\ncom.netflix.spectator:spectator-api:0.58.0\n\n\n\n\n\nThe bindings to integrate internally should be included with the application. In your code,\njust inject a registry, e.g.:\n\n\npublic\n \nclass\n \nFoo\n \n{\n\n  \n@Inject\n\n  \npublic\n \nFoo\n(\nRegistry\n \nregistry\n)\n \n{\n\n    \n...\n\n  \n}\n\n  \n...\n\n\n}\n\n\n\n\n\n\nSee the \ntesting docs\n for more information about creating a binding to use with tests.\n\n\nApplications\n\n\nApplication should include a dependency on the \natlas-client\n plugin:\n\n\nnetflix\n:\natlas\n-\nclient\n:\nlatest\n.\nrelease\n\n\n\n\n\n\nNote this is an internal only library with configs specific to the Netflix environments. It\nis assumed you are using Nebula so that internal maven repositories are available for your\nbuild. When configuring with governator specify the \nAtlasModule\n:\n\n\nInjector\n \ninjector\n \n=\n \nLifecycleInjector\n.\nbuilder\n()\n\n    \n.\nwithModules\n(\nnew\n \nAtlasModule\n())\n\n    \n.\nbuild\n()\n\n    \n.\ncreateInjector\n();\n\n\n\n\n\n\nThe registry binding will then be available so it can be injected as shown in the\n\nlibraries section\n. The insight libraries do not use any governator or guice\nspecific features. So it is possible to use guice or other dependency injection frameworks\ndirectly with the following caveats:\n\n\n\n\nHowever, some of the libraries do use the\n\n@PostConstruct\n and\n\n@PreDestroy\n annotations\nfor managing lifecycle. Governator adds lifecycle management and many other features on top of\nguice and is the recommended way. For more minimalist support of just the lifecycle annotations\non top of guice see \niep-guice\n.\n\n\nThe bindings and configuration necessary to run correctly with the internal setup are only\nsupported as guice modules. If trying to use some other dependency injection framework, then\nyou will be responsible for either finding a way to leverage the guice module in that framework\nor recreating those bindings and maintaining them as things change. It is not a paved road path.\n\n\n\n\nBase Server\n\n\nIf using \nbase-server\n, then you will get the Spectator and Atlas bindings automatically.\n\n\nAuto Plugin\n\n\n\n\nWarning\n\n\nDeprecated\n: Use of AutoBindSingleton is generally discouraged. It is recommended to\nuse one of the other methods.\n\n\n\n\nIf you are only interested in getting the GC logging, there is a library with an auto-bind\nsingleton that can be used:\n\n\ncom.netflix.spectator:spectator-nflx:0.58.0\n\n\n\n\n\nAssuming you are using karyon/base-server or governator with \ncom.netflix\n in the list of base\npackages then the plugin should get automatically loaded.", 
            "title": "Netflix Integration"
        }, 
        {
            "location": "/intro/netflix/#netflix-integration", 
            "text": "When running at Netflix, use the  atlas-client  library to enable transferring the\ninstrumented data to  Atlas . See the appropriate\nsection for the type of project you are working on:   Libraries  Applications , specifically standalone apps using guice or governator directly.  Base Server", 
            "title": "Netflix Integration"
        }, 
        {
            "location": "/intro/netflix/#libraries", 
            "text": "For libraries, the only dependency that should be needed is:  com.netflix.spectator:spectator-api:0.58.0  The bindings to integrate internally should be included with the application. In your code,\njust inject a registry, e.g.:  public   class   Foo   { \n   @Inject \n   public   Foo ( Registry   registry )   { \n     ... \n   } \n   ...  }   See the  testing docs  for more information about creating a binding to use with tests.", 
            "title": "Libraries"
        }, 
        {
            "location": "/intro/netflix/#applications", 
            "text": "Application should include a dependency on the  atlas-client  plugin:  netflix : atlas - client : latest . release   Note this is an internal only library with configs specific to the Netflix environments. It\nis assumed you are using Nebula so that internal maven repositories are available for your\nbuild. When configuring with governator specify the  AtlasModule :  Injector   injector   =   LifecycleInjector . builder () \n     . withModules ( new   AtlasModule ()) \n     . build () \n     . createInjector ();   The registry binding will then be available so it can be injected as shown in the libraries section . The insight libraries do not use any governator or guice\nspecific features. So it is possible to use guice or other dependency injection frameworks\ndirectly with the following caveats:   However, some of the libraries do use the @PostConstruct  and @PreDestroy  annotations\nfor managing lifecycle. Governator adds lifecycle management and many other features on top of\nguice and is the recommended way. For more minimalist support of just the lifecycle annotations\non top of guice see  iep-guice .  The bindings and configuration necessary to run correctly with the internal setup are only\nsupported as guice modules. If trying to use some other dependency injection framework, then\nyou will be responsible for either finding a way to leverage the guice module in that framework\nor recreating those bindings and maintaining them as things change. It is not a paved road path.", 
            "title": "Applications"
        }, 
        {
            "location": "/intro/netflix/#base-server", 
            "text": "If using  base-server , then you will get the Spectator and Atlas bindings automatically.", 
            "title": "Base Server"
        }, 
        {
            "location": "/intro/netflix/#auto-plugin", 
            "text": "Warning  Deprecated : Use of AutoBindSingleton is generally discouraged. It is recommended to\nuse one of the other methods.   If you are only interested in getting the GC logging, there is a library with an auto-bind\nsingleton that can be used:  com.netflix.spectator:spectator-nflx:0.58.0  Assuming you are using karyon/base-server or governator with  com.netflix  in the list of base\npackages then the plugin should get automatically loaded.", 
            "title": "Auto Plugin"
        }, 
        {
            "location": "/intro/servo-comparison/", 
            "text": "Servo Comparison\n\n\nServo\n is an alternative client monitoring\nlibrary that is also developed by Netflix. Originally spectator was an\nexperiment for a simpler API that wrapped servo. It was done as a separate\nproject to avoid breaking backwards compatibility for servo.\n\n\nFrom a user perspective, both will be supported for a long time, but most\nof our efforts for future improvement will go to spectator. For new code it\nis recommended to use the spectator API. If running\n\nat Netflix\n the correct bindings will be in place\nfor both servo and spectator.\n\n\nDifferences\n\n\nThis section provides a quick summary of the differences.\n\n\nSimpler API\n\n\nServo gives the user a lot of control, but this makes it hard to use\ncorrectly. For example, to create a counter the user needs to understand\nthe tradeoffs and choose between:\n\n\n\n\nBasicCounter\n\n\nDynamicCounter\n\n\nContextualCounter\n\n\nStepCounter\n\n\n\n\nFurther each of these can impact how data is reported to observers. The\nspectator API focuses on the constructs a user needs to instrument the\ncode. In spectator the user would always use the registry to create a\n\nCounter\n. The implementation details are left up to the\nregistry.\n\n\nThe \nregistration\n is simpler as well to avoid common pitfalls\nwhen using servo like overwriting a registered object.\n\n\nMore Focused\n\n\nThe goal of spectator is instrumenting code to send to a dimensional\ntime-series system like \nAtlas\n.\nServo has goals of staying compatible with a number of legacy libraries\nand naming formats, exposing data to JMX, etc. Examples of how this\ninfluences decisions:\n\n\n\n\nNo support for non-numeric data. Servo supported this for exposing to JMX.\n  Exposing the numeric data registered in spectator to JMX can be done\n  using a registry that supports it, but there is no goal to be a general\n  interface for exposing arbitrary data in JMX.\n\n\nNo support for customizeable time units when reporting timer data. Base\n  units should always be used for reporting and conversions can be performed\n  in the presentation layer if needed. It also avoids a lot of the confusion\n  around the timer unit for the data and issues like creating aggregates that\n  are meaningless because of mixed units.\n\n\n\n\nIt is better to have a simple way to get correct and easy to reason about\ndata to the backend than many options. If you want more knobs, then you can use\nServo.\n\n\nDI Friendly\n\n\nWhen servo was originally written dependency injection was not heavily used\nat Netflix. Further servo needed to stay compatible with a number of use-cases\nthat were heavily static.\n\n\nWhile spectator does have a static registry that can be used, the recommended\nway is to create a registry and inject it either manually or via a framework\ninto the classes that need it. This also makes it much easier to\n\ntest in isolation\n.\n\n\nMigration\n\n\nIf you want to migrate from the servo API to the spectator API, then this\nsection provides some guides on how servo constructs can be ported over. The\nsub-sections are the class names of monitor types supported by servo.\n\n\nFor users at Netflix, note we are not actively pushing teams to migrate\nor do any additional work. Servo is still supported and if it works for your\nuse-cases feel free to continue using it. \n\n\nRegistration\n\n\nFirst read through the \nservo docs on registration\n.\nIn servo if you have a class like:\n\n\npublic\n \nclass\n \nFoo\n \n{\n\n\n  \nprivate\n \nAtomicInteger\n \ngauge\n;\n\n  \nprivate\n \nCounter\n \ncounter\n;\n\n\n  \npublic\n \nFoo\n(\nString\n \nid\n)\n \n{\n\n    \ngauge\n \n=\n \nnew\n \nAtomicInteger\n();\n\n    \ncounter\n \n=\n \nnew\n \nBasicCounter\n(\nMonitorConfig\n.\nbuilder\n(\ncounter\n).\nbuild\n());\n\n    \nMonitors\n.\nregisterObject\n(\nid\n,\n \nthis\n);\n\n  \n}\n\n\n  \n@Monitor\n(\nname\n \n=\n \ngauge\n,\n \ntype\n \n=\n \nDataSourceType\n.\nGAUGE\n)\n\n  \nprivate\n \nint\n \ngauge\n()\n \n{\n\n    \nreturn\n \ngauge\n.\nget\n();\n\n  \n}\n\n\n  \npublic\n \nvoid\n \ndoSomething\n()\n \n{\n\n    \n...\n\n  \n}\n\n\n}\n\n\n\n\n\n\nThe state of the class is in the member variables of an instance of \nFoo\n.\nIf multiple instances of class \nFoo\n are created with the same value for \nid\n,\nthen the last one will overwrite the others for the registration. So the\nvalues getting reported will only be from the last instance registered. Also\nthe registry has a reference to the instance of \nFoo\n so it will never go\naway.\n\n\nFor counters and timers one way to get around this is to use\n\nDynamicCounter\n and \nDynamicTimer\n\nrespectively. Those classes will automatically handle the registration and\nexpire if there is no activity. They also get used for cases where the set\nof dimensions is not known up front.\n\n\nGauges need to sample the state of something so they need to have a reference\nto an object that contains the state. So the user would need to ensure that\nonly a single copy was registered leading to patterns like:\n\n\nclass\n \nFoo\n \n{\n\n\n  \nprivate\n \nstatic\n \nclass\n \nFooStats\n \n{\n\n\n    \nprivate\n \nAtomicInteger\n \ngauge\n;\n\n    \nprivate\n \nCounter\n \ncounter\n;\n\n\n    \npublic\n \nFooStats\n(\nString\n \nid\n)\n \n{\n\n      \ngauge\n \n=\n \nnew\n \nAtomicInteger\n();\n\n      \ncounter\n \n=\n \nnew\n \nBasicCounter\n(\nMonitorConfig\n.\nbuilder\n(\ncounter\n).\nbuild\n());\n\n      \nMonitors\n.\nregisterObject\n(\nid\n,\n \nthis\n);\n\n    \n}\n\n\n    \n@Monitor\n(\nname\n \n=\n \ngauge\n,\n \ntype\n \n=\n \nDataSourceType\n.\nGAUGE\n)\n\n    \nprivate\n \nint\n \ngauge\n()\n \n{\n\n      \nreturn\n \ngauge\n.\nget\n();\n\n    \n}\n\n  \n}\n\n\n  \nprivate\n \nstatic\n \nConcurrentHashMap\nString\n,\n \nFooStats\n \nSTATS\n \n=\n\n    \nnew\n \nConcurrentHashMap\n();\n\n\n  \nprivate\n \nfinal\n \nFooStats\n \nstats\n;\n\n\n  \npublic\n \nFoo\n(\nString\n \nid\n)\n \n{\n\n    \nstats\n \n=\n \nSTATS\n.\ncomputeIfAbsent\n(\nid\n,\n \n(\ni\n)\n \n-\n \nnew\n \nFooStats\n(\ni\n));\n\n  \n}\n\n\n  \npublic\n \nvoid\n \ndoSomething\n()\n \n{\n\n    \n...\n\n    \nstats\n.\nupdate\n();\n\n  \n}\n\n\n}\n\n\n\n\n\n\nThis ensures that there is a single copy for a given id. In spectator this\nexample would look like: \n\n\npublic\n \nclass\n \nFoo\n \n{\n\n\n  \nprivate\n \nAtomicInteger\n \ngauge\n;\n\n  \nprivate\n \nCounter\n \ncounter\n;\n\n\n  \npublic\n \nFoo\n(\nRegistry\n \nregistry\n,\n \nString\n \nid\n)\n \n{\n\n    \nId\n \ngaugeId\n \n=\n \nregistry\n.\ncreateId\n(\ngauge\n).\nwithTag\n(\nid\n,\n \nid\n);\n\n    \ngauge\n \n=\n \nregistry\n.\ngauge\n(\ngaugeId\n,\n \nnew\n \nAtomicInteger\n());\n\n    \ncounter\n \n=\n \nregistry\n.\ncounter\n(\ncounter\n,\n \nid\n,\n \nid\n);\n\n  \n}\n\n\n  \npublic\n \nvoid\n \ndoSomething\n()\n \n{\n\n    \n...\n\n  \n}\n\n\n}\n\n\n\n\n\n\nEverything using the same registry will get the same counter\ninstance if the same id is used. For the gauge the registry will\nkeep a weak reference and will sum the values if multiple instances are\npresent. Since it is a weak reference, nothing will prevent an instance of\n\nFoo\n from getting garbage collected.\n\n\nAnnotations\n\n\nAnnotations are not supported, use the appropriate meter type:\n\n\n\n\n\n\n\n\nDataSourceType\n\n\nSpectator Alternative\n\n\n\n\n\n\n\n\n\n\nCOUNTER\n\n\nCounter Usage\n\n\n\n\n\n\nGAUGE\n\n\nGauge Usage\n\n\n\n\n\n\nINFORMATIONAL\n\n\nNot supported\n\n\n\n\n\n\n\n\nBasicCounter\n\n\nSee the general overview of \nregistration differences\n and\nsummary of \ncounter usage\n.\n\n\nServo:\n\n\npublic\n \nclass\n \nFoo\n \n{\n\n  \nprivate\n \nfinal\n \nCounter\n \nc\n \n=\n\n    \nnew\n \nBasicCounter\n(\nMonitorConfig\n.\nbuilder\n(\nname\n).\nbuild\n());\n\n\n  \npublic\n \nFoo\n(\nString\n \nid\n)\n \n{\n\n    \nMonitors\n.\nregisterObject\n(\nid\n,\n \nthis\n);\n\n  \n}\n\n\n  \npublic\n \nvoid\n \ndoSomething\n()\n \n{\n\n    \nc\n.\nincrement\n();\n\n  \n}\n\n\n}\n\n\n\n\n\n\nSpectator:\n\n\npublic\n \nclass\n \nFoo\n \n{\n\n  \nprivate\n \nfinal\n \nCounter\n \nc\n;\n\n\n  \n@Inject\n\n  \npublic\n \nFoo\n(\nRegistry\n \nregistry\n,\n \nString\n \nid\n)\n \n{\n\n    \nc\n \n=\n \nregistry\n.\ncounter\n(\nname\n,\n \nid\n,\n \nid\n);\n\n  \n}\n\n\n  \npublic\n \nvoid\n \ndoSomething\n()\n \n{\n\n    \nc\n.\nincrement\n();\n\n  \n}\n\n\n}\n\n\n\n\n\n\nBasicGauge\n\n\nSee the general overview of \nregistration differences\n and\nsummary of \ngauge usage\n.\n\n\nServo:\n\n\npublic\n \nclass\n \nFoo\n \n{\n\n  \nprivate\n \nfinal\n \nBasicGauge\n \ng\n \n=\n \nnew\n \nBasicGauge\n(\n\n    \nMonitorConfig\n.\nbuilder\n(\nname\n).\nbuild\n(),\n\n    \nthis\n::\ngetCurrentValue\n);\n\n\n  \npublic\n \nFoo\n(\nString\n \nid\n)\n \n{\n\n    \nMonitors\n.\nregisterObject\n(\nid\n,\n \nthis\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\nSpectator:\n\n\npublic\n \nclass\n \nFoo\n \n{\n\n  \n@Inject\n\n  \npublic\n \nFoo\n(\nRegistry\n \nregistry\n,\n \nString\n \nid\n)\n \n{\n\n    \nId\n \ngaugeId\n \n=\n \nregistry\n.\ncreateId\n(\nname\n).\nwithTag\n(\nid\n,\n \nid\n);\n\n    \nregistry\n.\ngauge\n(\ngaugeId\n,\n \nthis\n,\n \nFoo\n::\ngetCurrentValue\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\nBasicTimer\n\n\nSee the general overview of \nregistration differences\n and\nsummary of \ntimer usage\n. Note in spectator the reported unit\nfor timers is always seconds and cannot be changed. Seconds is the base unit\nand other units should only be used as a presentation detail. Servo allows\nthe unit to be customized and defaults to milliseconds.\n\n\nServo:\n\n\npublic\n \nclass\n \nFoo\n \n{\n\n  \nprivate\n \nfinal\n \nTimer\n \nt\n \n=\n \nnew\n \nBasicTimer\n(\n\n    \nMonitorConfig\n.\nbuilder\n(\nname\n).\nbuild\n(),\n \nTimeUnit\n.\nSECONDS\n);\n\n\n  \npublic\n \nFoo\n(\nString\n \nid\n)\n \n{\n\n    \nMonitors\n.\nregisterObject\n(\nid\n,\n \nthis\n);\n\n  \n}\n\n\n  \npublic\n \nvoid\n \ndoSomething\n()\n \n{\n\n    \nStopwatch\n \ns\n \n=\n \nt\n.\nstart\n();\n\n    \ntry\n \n{\n\n      \n...\n\n    \n}\n \nfinally\n \n{\n\n      \ns\n.\nstop\n();\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\nSpectator:\n\n\npublic\n \nclass\n \nFoo\n \n{\n\n  \nprivate\n \nfinal\n \nTimer\n \nt\n;\n\n\n  \n@Inject\n\n  \npublic\n \nFoo\n(\nRegistry\n \nregistry\n,\n \nString\n \nid\n)\n \n{\n\n    \nt\n \n=\n \nregistry\n.\ntimer\n(\nname\n,\n \nid\n,\n \nid\n);\n\n  \n}\n\n\n  \npublic\n \nvoid\n \ndoSomething\n()\n \n{\n\n    \nt\n.\nrecord\n(()\n \n-\n \n{\n\n      \n...\n\n    \n});\n\n  \n}\n\n\n}\n\n\n\n\n\n\nBasicDistributionSummary\n\n\nSee the general overview of \nregistration differences\n and\nsummary of \ndistribution summary usage\n.\n\n\nServo:\n\n\npublic\n \nclass\n \nFoo\n \n{\n\n  \nprivate\n \nfinal\n \nBasicDistributionSummary\n \ns\n \n=\n \nnew\n \nBasicDistributionSummary\n(\n\n    \nMonitorConfig\n.\nbuilder\n(\nname\n).\nbuild\n());\n\n\n  \npublic\n \nFoo\n(\nString\n \nid\n)\n \n{\n\n    \nMonitors\n.\nregisterObject\n(\nid\n,\n \nthis\n);\n\n  \n}\n\n\n  \npublic\n \nvoid\n \ndoSomething\n()\n \n{\n\n    \n...\n\n    \ns\n.\nrecord\n(\ngetValue\n());\n\n  \n}\n\n\n}\n\n\n\n\n\n\nSpectator:\n\n\npublic\n \nclass\n \nFoo\n \n{\n\n  \nprivate\n \nfinal\n \nDistributionSummary\n \ns\n;\n\n\n  \n@Inject\n\n  \npublic\n \nFoo\n(\nRegistry\n \nregistry\n,\n \nString\n \nid\n)\n \n{\n\n    \ns\n \n=\n \nregistry\n.\ndistributionSummary\n(\nname\n,\n \nid\n,\n \nid\n);\n\n  \n}\n\n\n  \npublic\n \nvoid\n \ndoSomething\n()\n \n{\n\n    \n...\n\n    \ns\n.\nrecord\n(\ngetValue\n());\n\n  \n}\n\n\n}\n\n\n\n\n\n\nBasicInformational\n\n\nNot supported, see \noverview of differences\n.\n\n\nBasicStopwatch\n\n\nThere isn't an explicit stopwatch class in spectator. Just use a timing\ncall directly. \n\n\nServo:\n\n\n  \npublic\n \nvoid\n \ndoSomething\n()\n \n{\n\n    \nStopwatch\n \ns\n \n=\n \ntimer\n.\nstart\n();\n\n    \ntry\n \n{\n\n      \n...\n\n    \n}\n \nfinally\n \n{\n\n      \ns\n.\nstop\n();\n\n    \n}\n\n  \n}\n\n\n\n\n\n\nSpectator:\n\n\n  \npublic\n \nvoid\n \ndoSomething\n()\n \n{\n\n    \nfinal\n \nlong\n \ns\n \n=\n \nSystem\n.\nnanoTime\n();\n\n    \ntry\n \n{\n\n      \n...\n\n    \n}\n \nfinally\n \n{\n\n      \ntimer\n.\nrecord\n(\nSystem\n.\nnanoTime\n()\n \n-\n \ns\n,\n \nTimeUnit\n.\nNANOSECONDS\n);\n\n    \n}\n\n  \n}\n\n\n\n\n\n\nBucketTimer\n\n\nSee the general overview of \nregistration differences\n and\nsummary of \nsandbox documentation\n. Note in spectator BucketTimer is\nprovided in the sandbox extension library and may change in future as we\ngain more experience using it.\n\n\nServo:\n\n\npublic\n \nclass\n \nFoo\n \n{\n\n  \nprivate\n \nfinal\n \nTimer\n \nt\n \n=\n \nnew\n \nBucketTimer\n(\n\n    \nMonitorConfig\n.\nbuilder\n(\nname\n).\nbuild\n(),\n\n    \nnew\n \nBucketConfig\n.\nBuilder\n()\n\n      \n.\nwithTimeUnit\n(\nTimeUnit\n.\nMILLISECONDS\n)\n\n      \n.\nwithBuckets\n(\nnew\n \nlong\n[]\n \n{\n \n500\n,\n \n2500\n,\n \n5000\n,\n \n10000\n \n})\n\n      \n.\nbuild\n());\n\n\n  \npublic\n \nFoo\n(\nString\n \nid\n)\n \n{\n\n    \nMonitors\n.\nregisterObject\n(\nid\n,\n \nthis\n);\n\n  \n}\n\n\n  \npublic\n \nvoid\n \ndoSomething\n()\n \n{\n\n    \nStopwatch\n \ns\n \n=\n \nt\n.\nstart\n();\n\n    \ntry\n \n{\n\n      \n...\n\n    \n}\n \nfinally\n \n{\n\n      \ns\n.\nstop\n();\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\nSpectator:\n\n\npublic\n \nclass\n \nFoo\n \n{\n\n  \nprivate\n \nfinal\n \nTimer\n \nt\n;\n\n\n  \n@Inject\n\n  \npublic\n \nFoo\n(\nRegistry\n \nregistry\n,\n \nString\n \nid\n)\n \n{\n\n    \nId\n \ntimerId\n \n=\n \nregistry\n.\ncreateId\n(\nname\n,\n \nid\n,\n \nid\n);\n\n    \nBucketFunction\n \nf\n \n=\n \nBucketFunctions\n.\nlatency\n(\n10\n,\n \nTimeUnit\n.\nSECONDS\n);\n\n    \nt\n \n=\n \nBucketTimer\n.\nget\n(\nregistry\n,\n \ntimerId\n,\n \nf\n);\n\n  \n}\n\n\n  \npublic\n \nvoid\n \ndoSomething\n()\n \n{\n\n    \nt\n.\nrecord\n(()\n \n-\n \n{\n\n      \n...\n\n    \n});\n\n  \n}\n\n\n}\n\n\n\n\n\n\nContextualCounter\n\n\nNot supported. A fixed tag list for the context is too rigid and this class\nwas never used much at Netflix. Future work being looked at in\n\nissue-180\n.\n\n\nContextualTimer\n\n\nNot supported. A fixed tag list for the context is too rigid and this class\nwas never used much at Netflix. Future work being looked at in\n\nissue-180\n.\n\n\nDoubleGauge\n\n\nSee the general overview of \nregistration differences\n and\nsummary of \ngauge usage\n.\n\n\nServo:\n\n\npublic\n \nclass\n \nFoo\n \n{\n\n  \nprivate\n \nfinal\n \nDoubleGauge\n \ng\n \n=\n \nnew\n \nDoubleGauge\n(\n\n    \nMonitorConfig\n.\nbuilder\n(\nname\n).\nbuild\n());\n\n\n  \npublic\n \nFoo\n(\nString\n \nid\n)\n \n{\n\n    \nMonitors\n.\nregisterObject\n(\nid\n,\n \nthis\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\nSpectator:\n\n\nimport\n \ncom.google.common.util.concurrent.AtomicDouble\n;\n\n\n\npublic\n \nclass\n \nFoo\n \n{\n\n  \nprivate\n \nfinal\n \nAtomicDouble\n \nv\n;\n\n\n  \n@Inject\n\n  \npublic\n \nFoo\n(\nRegistry\n \nregistry\n,\n \nString\n \nid\n)\n \n{\n\n    \nId\n \ngaugeId\n \n=\n \nregistry\n.\ncreateId\n(\nname\n).\nwithTag\n(\nid\n,\n \nid\n);\n\n    \nv\n \n=\n \nregistry\n.\ngauge\n(\ngaugeId\n,\n \nnew\n \nAtomicDouble\n());\n\n  \n}\n\n\n}\n\n\n\n\n\n\nDurationTimer\n\n\nSee the general overview of \nregistration differences\n and\nsummary of \ntimer usage\n.\n\n\nServo:\n\n\npublic\n \nclass\n \nFoo\n \n{\n\n  \nprivate\n \nfinal\n \nDurationTimer\n \nt\n \n=\n \nnew\n \nDurationTimer\n(\n\n    \nMonitorConfig\n.\nbuilder\n(\nname\n).\nbuild\n());\n\n\n  \npublic\n \nFoo\n(\nString\n \nid\n)\n \n{\n\n    \nMonitors\n.\nregisterObject\n(\nid\n,\n \nthis\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\nSpectator:\n\n\npublic\n \nclass\n \nFoo\n \n{\n\n  \nprivate\n \nfinal\n \nLongTaskTimer\n \nt\n;\n\n\n  \n@Inject\n\n  \npublic\n \nFoo\n(\nRegistry\n \nregistry\n,\n \nString\n \nid\n)\n \n{\n\n    \nt\n \n=\n \nregistry\n.\nlongTaskTimer\n(\nname\n,\n \nid\n,\n \nid\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\nDynamicCounter\n\n\nSee the general overview of \nregistration differences\n and\nsummary of \ncounter usage\n.\n\n\nServo:\n\n\npublic\n \nclass\n \nFoo\n \n{\n\n\n  \nprivate\n \nfinal\n \nString\n \nid\n;\n\n\n  \npublic\n \nFoo\n(\nString\n \nid\n)\n \n{\n\n    \nthis\n.\nid\n \n=\n \nid\n;\n\n  \n}\n\n\n  \npublic\n \nvoid\n \ndoSomething\n(\nContext\n \nctxt\n)\n \n{\n\n    \nDynamicCounter\n.\nincrement\n(\nstaticId\n,\n \nid\n,\n \nid\n);\n\n    \nDynamicCounter\n.\nincrement\n(\ndynamicId\n,\n \nid\n,\n \nid\n,\n \nfoo\n,\n \nctxt\n.\ngetFoo\n());\n\n  \n}\n\n\n}\n\n\n\n\n\n\nSpectator:\n\n\npublic\n \nclass\n \nFoo\n \n{\n\n  \nprivate\n \nfinal\n \nRegistry\n \nregistry\n;\n\n  \nprivate\n \nfinal\n \nString\n \nid\n;\n\n  \nprivate\n \nfinal\n \nCounter\n \nstaticCounter\n;\n\n  \nprivate\n \nfinal\n \nId\n \ndynamicId\n;\n\n\n  \n@Inject\n\n  \npublic\n \nFoo\n(\nRegistry\n \nregistry\n,\n \nString\n \nid\n)\n \n{\n\n    \nthis\n.\nregistry\n \n=\n \nregistry\n;\n\n    \nthis\n.\nid\n \n=\n \nid\n;\n\n    \nstaticCounter\n \n=\n \nregistry\n.\ncounter\n(\nstaticId\n,\n \nid\n,\n \nid\n);\n\n    \ndynamicId\n \n=\n \nregistry\n.\ncreateId\n(\ndynamicId\n,\n \nid\n,\n \nid\n);\n\n  \n}\n\n\n  \npublic\n \nvoid\n \ndoSomething\n(\nContext\n \nctxt\n)\n \n{\n\n    \n// Keeping the reference to the counter avoids additional allocations\n\n    \n// to create the id object and the lookup cost\n\n    \nstaticCounter\n.\nincrement\n();\n\n\n    \n// If the id is dynamic it must be looked up\n\n    \nregistry\n.\ncounter\n(\ndynamicId\n,\n \nid\n,\n \nid\n,\n \nfoo\n,\n \nctxt\n.\ngetFoo\n()).\nincrement\n();\n\n\n    \n// This will update the same counter as the line above, but the base part\n\n    \n// of the id is precomputed to make it cheaper to construct the id.\n\n    \nregistry\n.\ncounter\n(\ndynamicId\n.\nwithTag\n(\nfoo\n,\n \nctxt\n.\ngetFoo\n())).\nincrement\n();\n\n  \n}\n\n\n}\n\n\n\n\n\n\nDynamicTimer\n\n\nSee the general overview of \nregistration differences\n and\nsummary of \ntimer usage\n.\n\n\nServo:\n\n\npublic\n \nclass\n \nFoo\n \n{\n\n\n  \nprivate\n \nfinal\n \nString\n \nid\n;\n\n  \nprivate\n \nfinal\n \nMonitorConfig\n \nstaticId\n;\n\n\n  \npublic\n \nFoo\n(\nString\n \nid\n)\n \n{\n\n    \nthis\n.\nid\n \n=\n \nid\n;\n\n    \nstaticId\n \n=\n \nMonitorConfig\n.\nbuilder\n(\nstaticId\n).\nwithTag\n(\nid\n,\n \nid\n).\nbuild\n();\n\n  \n}\n\n\n  \npublic\n \nvoid\n \ndoSomething\n(\nContext\n \nctxt\n)\n \n{\n\n    \nfinal\n \nlong\n \nd\n \n=\n \nctxt\n.\ngetDurationMillis\n();\n\n    \nDynamicTimer\n.\nrecord\n(\nstaticId\n,\n \nTimeUnit\n.\nSECONDS\n,\n \nd\n,\n \nTimeUnit\n.\nMILLISECONDS\n);\n\n\n    \nMonitorConfig\n \ndynamicId\n \n=\n \nMonitorConfig\n.\nbuilder\n(\ndynamicId\n)\n\n      \n.\nwithTag\n(\nid\n,\n \nid\n)\n\n      \n.\nwithTag\n(\nfoo\n,\n \nctxt\n.\ngetFoo\n())\n\n      \n.\nbuild\n();\n\n    \nDynamicTimer\n.\nrecord\n(\ndynamicId\n,\n \nTimeUnit\n.\nSECONDS\n,\n \nd\n,\n \nTimeUnit\n.\nMILLISECONDS\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\nSpectator:\n\n\npublic\n \nclass\n \nFoo\n \n{\n\n  \nprivate\n \nfinal\n \nRegistry\n \nregistry\n;\n\n  \nprivate\n \nfinal\n \nString\n \nid\n;\n\n  \nprivate\n \nfinal\n \nTimer\n \nstaticTimer\n;\n\n  \nprivate\n \nfinal\n \nId\n \ndynamicId\n;\n\n\n  \n@Inject\n\n  \npublic\n \nFoo\n(\nRegistry\n \nregistry\n,\n \nString\n \nid\n)\n \n{\n\n    \nthis\n.\nregistry\n \n=\n \nregistry\n;\n\n    \nthis\n.\nid\n \n=\n \nid\n;\n\n    \nstaticTimer\n \n=\n \nregistry\n.\ntimer\n(\nstaticId\n,\n \nid\n,\n \nid\n);\n\n    \ndynamicId\n \n=\n \nregistry\n.\ncreateId\n(\ndynamicId\n,\n \nid\n,\n \nid\n);\n\n  \n}\n\n\n  \npublic\n \nvoid\n \ndoSomething\n(\nContext\n \nctxt\n)\n \n{\n\n    \nfinal\n \nlong\n \nd\n \n=\n \nctxt\n.\ngetDurationMillis\n();\n\n\n    \n// Keeping the reference to the timer avoids additional allocations\n\n    \n// to create the id object and the lookup cost\n\n    \nstaticTimer\n.\nrecord\n(\nd\n,\n \nTimeUnit\n.\nMILLISECONDS\n);\n\n\n    \n// If the id is dynamic it must be looked up\n\n    \nregistry\n.\ntimer\n(\ndynamicId\n,\n \nid\n,\n \nid\n,\n \nfoo\n,\n \nctxt\n.\ngetFoo\n())\n\n      \n.\nrecord\n(\nd\n,\n \nTimeUnit\n.\nMILLISECONDS\n);\n\n\n    \n// This will update the same timer as the line above, but the base part\n\n    \n// of the id is precomputed to make it cheaper to construct the id.\n\n    \nregistry\n.\ntimer\n(\ndynamicId\n.\nwithTag\n(\nfoo\n,\n \nctxt\n.\ngetFoo\n()))\n\n      \n.\nrecord\n(\nd\n,\n \nTimeUnit\n.\nMILLISECONDS\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\nLongGauge\n\n\nSee the general overview of \nregistration differences\n and\nsummary of \ngauge usage\n.\n\n\nServo:\n\n\npublic\n \nclass\n \nFoo\n \n{\n\n  \nprivate\n \nfinal\n \nLongGauge\n \ng\n \n=\n \nnew\n \nLongGauge\n(\n\n    \nMonitorConfig\n.\nbuilder\n(\nname\n).\nbuild\n());\n\n\n  \npublic\n \nFoo\n(\nString\n \nid\n)\n \n{\n\n    \nMonitors\n.\nregisterObject\n(\nid\n,\n \nthis\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\nSpectator:\n\n\npublic\n \nclass\n \nFoo\n \n{\n\n  \nprivate\n \nfinal\n \nAtomicLong\n \nv\n;\n\n\n  \n@Inject\n\n  \npublic\n \nFoo\n(\nRegistry\n \nregistry\n,\n \nString\n \nid\n)\n \n{\n\n    \nId\n \ngaugeId\n \n=\n \nregistry\n.\ncreateId\n(\nname\n).\nwithTag\n(\nid\n,\n \nid\n);\n\n    \nv\n \n=\n \nregistry\n.\ngauge\n(\ngaugeId\n,\n \nnew\n \nAtomicLong\n());\n\n  \n}\n\n\n}\n\n\n\n\n\n\nMonitorConfig\n\n\nSee the documentation on \nnaming\n.\n\n\nServo:\n\n\nMonitorConfig\n \nid\n \n=\n \nMonitorConfig\n.\nbuilder\n(\nname\n)\n\n  \n.\nwithTag\n(\ncountry\n,\n \nUS\n)\n\n  \n.\nwithTag\n(\ndevice\n,\n  \nxbox\n)\n\n  \n.\nbuild\n();\n\n\n\n\n\n\nSpectator:\n\n\nId\n \nid\n \n=\n \nregistry\n.\ncreateId\n(\nname\n)\n\n  \n.\nwithTag\n(\ncountry\n,\n \nUS\n)\n\n  \n.\nwithTag\n(\ndevice\n,\n  \nxbox\n);\n\n\n\n// or\n\n\n\nId\n \nid\n \n=\n \nregistry\n.\ncreateId\n(\nname\n,\n \ncountry\n,\n \nUS\n,\n \ndevice\n,\n \nxbox\n);\n\n\n\n\n\n\nMonitoredCache\n\n\nNot supported because spectator does not have a direct dependency on guava.\nIf there is enough demand an extension can be created.\n\n\nNumberGauge\n\n\nSee the general overview of \nregistration differences\n and\nsummary of \ngauge usage\n.\n\n\nServo:\n\n\npublic\n \nclass\n \nFoo\n \n{\n\n  \nprivate\n \nfinal\n \nNumberGauge\n \ng\n \n=\n \nnew\n \nNumberGauge\n(\n\n    \nMonitorConfig\n.\nbuilder\n(\nname\n).\nbuild\n(),\n \nnew\n \nAtomicLong\n());\n\n\n  \npublic\n \nFoo\n(\nString\n \nid\n)\n \n{\n\n    \nMonitors\n.\nregisterObject\n(\nid\n,\n \nthis\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\nSpectator:\n\n\npublic\n \nclass\n \nFoo\n \n{\n\n  \nprivate\n \nfinal\n \nAtomicLong\n \nv\n;\n\n\n  \n@Inject\n\n  \npublic\n \nFoo\n(\nRegistry\n \nregistry\n,\n \nString\n \nid\n)\n \n{\n\n    \nId\n \ngaugeId\n \n=\n \nregistry\n.\ncreateId\n(\nname\n).\nwithTag\n(\nid\n,\n \nid\n);\n\n    \nv\n \n=\n \nregistry\n.\ngauge\n(\ngaugeId\n,\n \nnew\n \nAtomicLong\n());\n\n  \n}\n\n\n}\n\n\n\n\n\n\nStatsTimer\n\n\nNot supported, see \noverview of differences\n.\n\n\nStepCounter\n\n\nSee the general overview of \nregistration differences\n and\nsummary of \ncounter usage\n.\n\n\nServo:\n\n\npublic\n \nclass\n \nFoo\n \n{\n\n  \nprivate\n \nfinal\n \nCounter\n \nc\n \n=\n\n    \nnew\n \nStepCounter\n(\nMonitorConfig\n.\nbuilder\n(\nname\n).\nbuild\n());\n\n\n  \npublic\n \nFoo\n(\nString\n \nid\n)\n \n{\n\n    \nMonitors\n.\nregisterObject\n(\nid\n,\n \nthis\n);\n\n  \n}\n\n\n  \npublic\n \nvoid\n \ndoSomething\n()\n \n{\n\n    \nc\n.\nincrement\n();\n\n  \n}\n\n\n}\n\n\n\n\n\n\nSpectator:\n\n\npublic\n \nclass\n \nFoo\n \n{\n\n  \nprivate\n \nfinal\n \nCounter\n \nc\n;\n\n\n  \n@Inject\n\n  \npublic\n \nFoo\n(\nRegistry\n \nregistry\n,\n \nString\n \nid\n)\n \n{\n\n    \nc\n \n=\n \nregistry\n.\ncounter\n(\nname\n,\n \nid\n,\n \nid\n);\n\n  \n}\n\n\n  \npublic\n \nvoid\n \ndoSomething\n()\n \n{\n\n    \nc\n.\nincrement\n();\n\n  \n}\n\n\n}", 
            "title": "Servo Comparison"
        }, 
        {
            "location": "/intro/servo-comparison/#servo-comparison", 
            "text": "Servo  is an alternative client monitoring\nlibrary that is also developed by Netflix. Originally spectator was an\nexperiment for a simpler API that wrapped servo. It was done as a separate\nproject to avoid breaking backwards compatibility for servo.  From a user perspective, both will be supported for a long time, but most\nof our efforts for future improvement will go to spectator. For new code it\nis recommended to use the spectator API. If running at Netflix  the correct bindings will be in place\nfor both servo and spectator.", 
            "title": "Servo Comparison"
        }, 
        {
            "location": "/intro/servo-comparison/#differences", 
            "text": "This section provides a quick summary of the differences.", 
            "title": "Differences"
        }, 
        {
            "location": "/intro/servo-comparison/#simpler-api", 
            "text": "Servo gives the user a lot of control, but this makes it hard to use\ncorrectly. For example, to create a counter the user needs to understand\nthe tradeoffs and choose between:   BasicCounter  DynamicCounter  ContextualCounter  StepCounter   Further each of these can impact how data is reported to observers. The\nspectator API focuses on the constructs a user needs to instrument the\ncode. In spectator the user would always use the registry to create a Counter . The implementation details are left up to the\nregistry.  The  registration  is simpler as well to avoid common pitfalls\nwhen using servo like overwriting a registered object.", 
            "title": "Simpler API"
        }, 
        {
            "location": "/intro/servo-comparison/#more-focused", 
            "text": "The goal of spectator is instrumenting code to send to a dimensional\ntime-series system like  Atlas .\nServo has goals of staying compatible with a number of legacy libraries\nand naming formats, exposing data to JMX, etc. Examples of how this\ninfluences decisions:   No support for non-numeric data. Servo supported this for exposing to JMX.\n  Exposing the numeric data registered in spectator to JMX can be done\n  using a registry that supports it, but there is no goal to be a general\n  interface for exposing arbitrary data in JMX.  No support for customizeable time units when reporting timer data. Base\n  units should always be used for reporting and conversions can be performed\n  in the presentation layer if needed. It also avoids a lot of the confusion\n  around the timer unit for the data and issues like creating aggregates that\n  are meaningless because of mixed units.   It is better to have a simple way to get correct and easy to reason about\ndata to the backend than many options. If you want more knobs, then you can use\nServo.", 
            "title": "More Focused"
        }, 
        {
            "location": "/intro/servo-comparison/#di-friendly", 
            "text": "When servo was originally written dependency injection was not heavily used\nat Netflix. Further servo needed to stay compatible with a number of use-cases\nthat were heavily static.  While spectator does have a static registry that can be used, the recommended\nway is to create a registry and inject it either manually or via a framework\ninto the classes that need it. This also makes it much easier to test in isolation .", 
            "title": "DI Friendly"
        }, 
        {
            "location": "/intro/servo-comparison/#migration", 
            "text": "If you want to migrate from the servo API to the spectator API, then this\nsection provides some guides on how servo constructs can be ported over. The\nsub-sections are the class names of monitor types supported by servo.  For users at Netflix, note we are not actively pushing teams to migrate\nor do any additional work. Servo is still supported and if it works for your\nuse-cases feel free to continue using it.", 
            "title": "Migration"
        }, 
        {
            "location": "/intro/servo-comparison/#registration", 
            "text": "First read through the  servo docs on registration .\nIn servo if you have a class like:  public   class   Foo   { \n\n   private   AtomicInteger   gauge ; \n   private   Counter   counter ; \n\n   public   Foo ( String   id )   { \n     gauge   =   new   AtomicInteger (); \n     counter   =   new   BasicCounter ( MonitorConfig . builder ( counter ). build ()); \n     Monitors . registerObject ( id ,   this ); \n   } \n\n   @Monitor ( name   =   gauge ,   type   =   DataSourceType . GAUGE ) \n   private   int   gauge ()   { \n     return   gauge . get (); \n   } \n\n   public   void   doSomething ()   { \n     ... \n   }  }   The state of the class is in the member variables of an instance of  Foo .\nIf multiple instances of class  Foo  are created with the same value for  id ,\nthen the last one will overwrite the others for the registration. So the\nvalues getting reported will only be from the last instance registered. Also\nthe registry has a reference to the instance of  Foo  so it will never go\naway.  For counters and timers one way to get around this is to use DynamicCounter  and  DynamicTimer \nrespectively. Those classes will automatically handle the registration and\nexpire if there is no activity. They also get used for cases where the set\nof dimensions is not known up front.  Gauges need to sample the state of something so they need to have a reference\nto an object that contains the state. So the user would need to ensure that\nonly a single copy was registered leading to patterns like:  class   Foo   { \n\n   private   static   class   FooStats   { \n\n     private   AtomicInteger   gauge ; \n     private   Counter   counter ; \n\n     public   FooStats ( String   id )   { \n       gauge   =   new   AtomicInteger (); \n       counter   =   new   BasicCounter ( MonitorConfig . builder ( counter ). build ()); \n       Monitors . registerObject ( id ,   this ); \n     } \n\n     @Monitor ( name   =   gauge ,   type   =   DataSourceType . GAUGE ) \n     private   int   gauge ()   { \n       return   gauge . get (); \n     } \n   } \n\n   private   static   ConcurrentHashMap String ,   FooStats   STATS   = \n     new   ConcurrentHashMap (); \n\n   private   final   FooStats   stats ; \n\n   public   Foo ( String   id )   { \n     stats   =   STATS . computeIfAbsent ( id ,   ( i )   -   new   FooStats ( i )); \n   } \n\n   public   void   doSomething ()   { \n     ... \n     stats . update (); \n   }  }   This ensures that there is a single copy for a given id. In spectator this\nexample would look like:   public   class   Foo   { \n\n   private   AtomicInteger   gauge ; \n   private   Counter   counter ; \n\n   public   Foo ( Registry   registry ,   String   id )   { \n     Id   gaugeId   =   registry . createId ( gauge ). withTag ( id ,   id ); \n     gauge   =   registry . gauge ( gaugeId ,   new   AtomicInteger ()); \n     counter   =   registry . counter ( counter ,   id ,   id ); \n   } \n\n   public   void   doSomething ()   { \n     ... \n   }  }   Everything using the same registry will get the same counter\ninstance if the same id is used. For the gauge the registry will\nkeep a weak reference and will sum the values if multiple instances are\npresent. Since it is a weak reference, nothing will prevent an instance of Foo  from getting garbage collected.", 
            "title": "Registration"
        }, 
        {
            "location": "/intro/servo-comparison/#annotations", 
            "text": "Annotations are not supported, use the appropriate meter type:     DataSourceType  Spectator Alternative      COUNTER  Counter Usage    GAUGE  Gauge Usage    INFORMATIONAL  Not supported", 
            "title": "Annotations"
        }, 
        {
            "location": "/intro/servo-comparison/#basiccounter", 
            "text": "See the general overview of  registration differences  and\nsummary of  counter usage .  Servo:  public   class   Foo   { \n   private   final   Counter   c   = \n     new   BasicCounter ( MonitorConfig . builder ( name ). build ()); \n\n   public   Foo ( String   id )   { \n     Monitors . registerObject ( id ,   this ); \n   } \n\n   public   void   doSomething ()   { \n     c . increment (); \n   }  }   Spectator:  public   class   Foo   { \n   private   final   Counter   c ; \n\n   @Inject \n   public   Foo ( Registry   registry ,   String   id )   { \n     c   =   registry . counter ( name ,   id ,   id ); \n   } \n\n   public   void   doSomething ()   { \n     c . increment (); \n   }  }", 
            "title": "BasicCounter"
        }, 
        {
            "location": "/intro/servo-comparison/#basicgauge", 
            "text": "See the general overview of  registration differences  and\nsummary of  gauge usage .  Servo:  public   class   Foo   { \n   private   final   BasicGauge   g   =   new   BasicGauge ( \n     MonitorConfig . builder ( name ). build (), \n     this :: getCurrentValue ); \n\n   public   Foo ( String   id )   { \n     Monitors . registerObject ( id ,   this ); \n   }  }   Spectator:  public   class   Foo   { \n   @Inject \n   public   Foo ( Registry   registry ,   String   id )   { \n     Id   gaugeId   =   registry . createId ( name ). withTag ( id ,   id ); \n     registry . gauge ( gaugeId ,   this ,   Foo :: getCurrentValue ); \n   }  }", 
            "title": "BasicGauge"
        }, 
        {
            "location": "/intro/servo-comparison/#basictimer", 
            "text": "See the general overview of  registration differences  and\nsummary of  timer usage . Note in spectator the reported unit\nfor timers is always seconds and cannot be changed. Seconds is the base unit\nand other units should only be used as a presentation detail. Servo allows\nthe unit to be customized and defaults to milliseconds.  Servo:  public   class   Foo   { \n   private   final   Timer   t   =   new   BasicTimer ( \n     MonitorConfig . builder ( name ). build (),   TimeUnit . SECONDS ); \n\n   public   Foo ( String   id )   { \n     Monitors . registerObject ( id ,   this ); \n   } \n\n   public   void   doSomething ()   { \n     Stopwatch   s   =   t . start (); \n     try   { \n       ... \n     }   finally   { \n       s . stop (); \n     } \n   }  }   Spectator:  public   class   Foo   { \n   private   final   Timer   t ; \n\n   @Inject \n   public   Foo ( Registry   registry ,   String   id )   { \n     t   =   registry . timer ( name ,   id ,   id ); \n   } \n\n   public   void   doSomething ()   { \n     t . record (()   -   { \n       ... \n     }); \n   }  }", 
            "title": "BasicTimer"
        }, 
        {
            "location": "/intro/servo-comparison/#basicdistributionsummary", 
            "text": "See the general overview of  registration differences  and\nsummary of  distribution summary usage .  Servo:  public   class   Foo   { \n   private   final   BasicDistributionSummary   s   =   new   BasicDistributionSummary ( \n     MonitorConfig . builder ( name ). build ()); \n\n   public   Foo ( String   id )   { \n     Monitors . registerObject ( id ,   this ); \n   } \n\n   public   void   doSomething ()   { \n     ... \n     s . record ( getValue ()); \n   }  }   Spectator:  public   class   Foo   { \n   private   final   DistributionSummary   s ; \n\n   @Inject \n   public   Foo ( Registry   registry ,   String   id )   { \n     s   =   registry . distributionSummary ( name ,   id ,   id ); \n   } \n\n   public   void   doSomething ()   { \n     ... \n     s . record ( getValue ()); \n   }  }", 
            "title": "BasicDistributionSummary"
        }, 
        {
            "location": "/intro/servo-comparison/#basicinformational", 
            "text": "Not supported, see  overview of differences .", 
            "title": "BasicInformational"
        }, 
        {
            "location": "/intro/servo-comparison/#basicstopwatch", 
            "text": "There isn't an explicit stopwatch class in spectator. Just use a timing\ncall directly.   Servo:     public   void   doSomething ()   { \n     Stopwatch   s   =   timer . start (); \n     try   { \n       ... \n     }   finally   { \n       s . stop (); \n     } \n   }   Spectator:     public   void   doSomething ()   { \n     final   long   s   =   System . nanoTime (); \n     try   { \n       ... \n     }   finally   { \n       timer . record ( System . nanoTime ()   -   s ,   TimeUnit . NANOSECONDS ); \n     } \n   }", 
            "title": "BasicStopwatch"
        }, 
        {
            "location": "/intro/servo-comparison/#buckettimer", 
            "text": "See the general overview of  registration differences  and\nsummary of  sandbox documentation . Note in spectator BucketTimer is\nprovided in the sandbox extension library and may change in future as we\ngain more experience using it.  Servo:  public   class   Foo   { \n   private   final   Timer   t   =   new   BucketTimer ( \n     MonitorConfig . builder ( name ). build (), \n     new   BucketConfig . Builder () \n       . withTimeUnit ( TimeUnit . MILLISECONDS ) \n       . withBuckets ( new   long []   {   500 ,   2500 ,   5000 ,   10000   }) \n       . build ()); \n\n   public   Foo ( String   id )   { \n     Monitors . registerObject ( id ,   this ); \n   } \n\n   public   void   doSomething ()   { \n     Stopwatch   s   =   t . start (); \n     try   { \n       ... \n     }   finally   { \n       s . stop (); \n     } \n   }  }   Spectator:  public   class   Foo   { \n   private   final   Timer   t ; \n\n   @Inject \n   public   Foo ( Registry   registry ,   String   id )   { \n     Id   timerId   =   registry . createId ( name ,   id ,   id ); \n     BucketFunction   f   =   BucketFunctions . latency ( 10 ,   TimeUnit . SECONDS ); \n     t   =   BucketTimer . get ( registry ,   timerId ,   f ); \n   } \n\n   public   void   doSomething ()   { \n     t . record (()   -   { \n       ... \n     }); \n   }  }", 
            "title": "BucketTimer"
        }, 
        {
            "location": "/intro/servo-comparison/#contextualcounter", 
            "text": "Not supported. A fixed tag list for the context is too rigid and this class\nwas never used much at Netflix. Future work being looked at in issue-180 .", 
            "title": "ContextualCounter"
        }, 
        {
            "location": "/intro/servo-comparison/#contextualtimer", 
            "text": "Not supported. A fixed tag list for the context is too rigid and this class\nwas never used much at Netflix. Future work being looked at in issue-180 .", 
            "title": "ContextualTimer"
        }, 
        {
            "location": "/intro/servo-comparison/#doublegauge", 
            "text": "See the general overview of  registration differences  and\nsummary of  gauge usage .  Servo:  public   class   Foo   { \n   private   final   DoubleGauge   g   =   new   DoubleGauge ( \n     MonitorConfig . builder ( name ). build ()); \n\n   public   Foo ( String   id )   { \n     Monitors . registerObject ( id ,   this ); \n   }  }   Spectator:  import   com.google.common.util.concurrent.AtomicDouble ;  public   class   Foo   { \n   private   final   AtomicDouble   v ; \n\n   @Inject \n   public   Foo ( Registry   registry ,   String   id )   { \n     Id   gaugeId   =   registry . createId ( name ). withTag ( id ,   id ); \n     v   =   registry . gauge ( gaugeId ,   new   AtomicDouble ()); \n   }  }", 
            "title": "DoubleGauge"
        }, 
        {
            "location": "/intro/servo-comparison/#durationtimer", 
            "text": "See the general overview of  registration differences  and\nsummary of  timer usage .  Servo:  public   class   Foo   { \n   private   final   DurationTimer   t   =   new   DurationTimer ( \n     MonitorConfig . builder ( name ). build ()); \n\n   public   Foo ( String   id )   { \n     Monitors . registerObject ( id ,   this ); \n   }  }   Spectator:  public   class   Foo   { \n   private   final   LongTaskTimer   t ; \n\n   @Inject \n   public   Foo ( Registry   registry ,   String   id )   { \n     t   =   registry . longTaskTimer ( name ,   id ,   id ); \n   }  }", 
            "title": "DurationTimer"
        }, 
        {
            "location": "/intro/servo-comparison/#dynamiccounter", 
            "text": "See the general overview of  registration differences  and\nsummary of  counter usage .  Servo:  public   class   Foo   { \n\n   private   final   String   id ; \n\n   public   Foo ( String   id )   { \n     this . id   =   id ; \n   } \n\n   public   void   doSomething ( Context   ctxt )   { \n     DynamicCounter . increment ( staticId ,   id ,   id ); \n     DynamicCounter . increment ( dynamicId ,   id ,   id ,   foo ,   ctxt . getFoo ()); \n   }  }   Spectator:  public   class   Foo   { \n   private   final   Registry   registry ; \n   private   final   String   id ; \n   private   final   Counter   staticCounter ; \n   private   final   Id   dynamicId ; \n\n   @Inject \n   public   Foo ( Registry   registry ,   String   id )   { \n     this . registry   =   registry ; \n     this . id   =   id ; \n     staticCounter   =   registry . counter ( staticId ,   id ,   id ); \n     dynamicId   =   registry . createId ( dynamicId ,   id ,   id ); \n   } \n\n   public   void   doSomething ( Context   ctxt )   { \n     // Keeping the reference to the counter avoids additional allocations \n     // to create the id object and the lookup cost \n     staticCounter . increment (); \n\n     // If the id is dynamic it must be looked up \n     registry . counter ( dynamicId ,   id ,   id ,   foo ,   ctxt . getFoo ()). increment (); \n\n     // This will update the same counter as the line above, but the base part \n     // of the id is precomputed to make it cheaper to construct the id. \n     registry . counter ( dynamicId . withTag ( foo ,   ctxt . getFoo ())). increment (); \n   }  }", 
            "title": "DynamicCounter"
        }, 
        {
            "location": "/intro/servo-comparison/#dynamictimer", 
            "text": "See the general overview of  registration differences  and\nsummary of  timer usage .  Servo:  public   class   Foo   { \n\n   private   final   String   id ; \n   private   final   MonitorConfig   staticId ; \n\n   public   Foo ( String   id )   { \n     this . id   =   id ; \n     staticId   =   MonitorConfig . builder ( staticId ). withTag ( id ,   id ). build (); \n   } \n\n   public   void   doSomething ( Context   ctxt )   { \n     final   long   d   =   ctxt . getDurationMillis (); \n     DynamicTimer . record ( staticId ,   TimeUnit . SECONDS ,   d ,   TimeUnit . MILLISECONDS ); \n\n     MonitorConfig   dynamicId   =   MonitorConfig . builder ( dynamicId ) \n       . withTag ( id ,   id ) \n       . withTag ( foo ,   ctxt . getFoo ()) \n       . build (); \n     DynamicTimer . record ( dynamicId ,   TimeUnit . SECONDS ,   d ,   TimeUnit . MILLISECONDS ); \n   }  }   Spectator:  public   class   Foo   { \n   private   final   Registry   registry ; \n   private   final   String   id ; \n   private   final   Timer   staticTimer ; \n   private   final   Id   dynamicId ; \n\n   @Inject \n   public   Foo ( Registry   registry ,   String   id )   { \n     this . registry   =   registry ; \n     this . id   =   id ; \n     staticTimer   =   registry . timer ( staticId ,   id ,   id ); \n     dynamicId   =   registry . createId ( dynamicId ,   id ,   id ); \n   } \n\n   public   void   doSomething ( Context   ctxt )   { \n     final   long   d   =   ctxt . getDurationMillis (); \n\n     // Keeping the reference to the timer avoids additional allocations \n     // to create the id object and the lookup cost \n     staticTimer . record ( d ,   TimeUnit . MILLISECONDS ); \n\n     // If the id is dynamic it must be looked up \n     registry . timer ( dynamicId ,   id ,   id ,   foo ,   ctxt . getFoo ()) \n       . record ( d ,   TimeUnit . MILLISECONDS ); \n\n     // This will update the same timer as the line above, but the base part \n     // of the id is precomputed to make it cheaper to construct the id. \n     registry . timer ( dynamicId . withTag ( foo ,   ctxt . getFoo ())) \n       . record ( d ,   TimeUnit . MILLISECONDS ); \n   }  }", 
            "title": "DynamicTimer"
        }, 
        {
            "location": "/intro/servo-comparison/#longgauge", 
            "text": "See the general overview of  registration differences  and\nsummary of  gauge usage .  Servo:  public   class   Foo   { \n   private   final   LongGauge   g   =   new   LongGauge ( \n     MonitorConfig . builder ( name ). build ()); \n\n   public   Foo ( String   id )   { \n     Monitors . registerObject ( id ,   this ); \n   }  }   Spectator:  public   class   Foo   { \n   private   final   AtomicLong   v ; \n\n   @Inject \n   public   Foo ( Registry   registry ,   String   id )   { \n     Id   gaugeId   =   registry . createId ( name ). withTag ( id ,   id ); \n     v   =   registry . gauge ( gaugeId ,   new   AtomicLong ()); \n   }  }", 
            "title": "LongGauge"
        }, 
        {
            "location": "/intro/servo-comparison/#monitorconfig", 
            "text": "See the documentation on  naming .  Servo:  MonitorConfig   id   =   MonitorConfig . builder ( name ) \n   . withTag ( country ,   US ) \n   . withTag ( device ,    xbox ) \n   . build ();   Spectator:  Id   id   =   registry . createId ( name ) \n   . withTag ( country ,   US ) \n   . withTag ( device ,    xbox );  // or  Id   id   =   registry . createId ( name ,   country ,   US ,   device ,   xbox );", 
            "title": "MonitorConfig"
        }, 
        {
            "location": "/intro/servo-comparison/#monitoredcache", 
            "text": "Not supported because spectator does not have a direct dependency on guava.\nIf there is enough demand an extension can be created.", 
            "title": "MonitoredCache"
        }, 
        {
            "location": "/intro/servo-comparison/#numbergauge", 
            "text": "See the general overview of  registration differences  and\nsummary of  gauge usage .  Servo:  public   class   Foo   { \n   private   final   NumberGauge   g   =   new   NumberGauge ( \n     MonitorConfig . builder ( name ). build (),   new   AtomicLong ()); \n\n   public   Foo ( String   id )   { \n     Monitors . registerObject ( id ,   this ); \n   }  }   Spectator:  public   class   Foo   { \n   private   final   AtomicLong   v ; \n\n   @Inject \n   public   Foo ( Registry   registry ,   String   id )   { \n     Id   gaugeId   =   registry . createId ( name ). withTag ( id ,   id ); \n     v   =   registry . gauge ( gaugeId ,   new   AtomicLong ()); \n   }  }", 
            "title": "NumberGauge"
        }, 
        {
            "location": "/intro/servo-comparison/#statstimer", 
            "text": "Not supported, see  overview of differences .", 
            "title": "StatsTimer"
        }, 
        {
            "location": "/intro/servo-comparison/#stepcounter", 
            "text": "See the general overview of  registration differences  and\nsummary of  counter usage .  Servo:  public   class   Foo   { \n   private   final   Counter   c   = \n     new   StepCounter ( MonitorConfig . builder ( name ). build ()); \n\n   public   Foo ( String   id )   { \n     Monitors . registerObject ( id ,   this ); \n   } \n\n   public   void   doSomething ()   { \n     c . increment (); \n   }  }   Spectator:  public   class   Foo   { \n   private   final   Counter   c ; \n\n   @Inject \n   public   Foo ( Registry   registry ,   String   id )   { \n     c   =   registry . counter ( name ,   id ,   id ); \n   } \n\n   public   void   doSomething ()   { \n     c . increment (); \n   }  }", 
            "title": "StepCounter"
        }, 
        {
            "location": "/ext/jvm-buffer-pools/", 
            "text": "Buffer Pools\n\n\nBuffer pools, such as direct byte buffers, can be monitored at a high level using the\n\nBufferPoolMXBean\n\nprovided by the JDK. \n\n\nGetting Started\n\n\nTo get information about buffer pools in spectator just setup registration of standard MXBeans.\nNote, if you are building an app at Netflix this should happen automatically via the normal\nplatform initialization.\n\n\nimport\n \ncom.netflix.spectator.api.Spectator\n;\n\n\nimport\n \ncom.netflix.spectator.jvm.Jmx\n;\n\n\n\nJmx\n.\nregisterStandardMXBeans\n(\nSpectator\n.\nregistry\n());\n\n\n\n\n\n\nMetrics\n\n\njvm.buffer.count\n\n\nGauge showing the current number of distinct buffers.\n\n\nUnit:\n count \n\n\nDimensions:\n\n\n\n\nid\n: type of buffers. Value will be either \ndirect\n for direct byte buffers or \nmapped\n for\n  memory mapped files.\n\n\n\n\njvm.buffer.memoryUsed\n\n\nGauge showing the current number of bytes used by all buffers.\n\n\nUnit:\n bytes \n\n\nDimensions:\n\n\n\n\nid\n: type of buffers. Value will be either \ndirect\n for direct byte buffers or \nmapped\n for\n  memory mapped files.", 
            "title": "Buffer Pools"
        }, 
        {
            "location": "/ext/jvm-buffer-pools/#buffer-pools", 
            "text": "Buffer pools, such as direct byte buffers, can be monitored at a high level using the BufferPoolMXBean \nprovided by the JDK.", 
            "title": "Buffer Pools"
        }, 
        {
            "location": "/ext/jvm-buffer-pools/#getting-started", 
            "text": "To get information about buffer pools in spectator just setup registration of standard MXBeans.\nNote, if you are building an app at Netflix this should happen automatically via the normal\nplatform initialization.  import   com.netflix.spectator.api.Spectator ;  import   com.netflix.spectator.jvm.Jmx ;  Jmx . registerStandardMXBeans ( Spectator . registry ());", 
            "title": "Getting Started"
        }, 
        {
            "location": "/ext/jvm-buffer-pools/#metrics", 
            "text": "", 
            "title": "Metrics"
        }, 
        {
            "location": "/ext/jvm-buffer-pools/#jvmbuffercount", 
            "text": "Gauge showing the current number of distinct buffers.  Unit:  count   Dimensions:   id : type of buffers. Value will be either  direct  for direct byte buffers or  mapped  for\n  memory mapped files.", 
            "title": "jvm.buffer.count"
        }, 
        {
            "location": "/ext/jvm-buffer-pools/#jvmbuffermemoryused", 
            "text": "Gauge showing the current number of bytes used by all buffers.  Unit:  bytes   Dimensions:   id : type of buffers. Value will be either  direct  for direct byte buffers or  mapped  for\n  memory mapped files.", 
            "title": "jvm.buffer.memoryUsed"
        }, 
        {
            "location": "/ext/jvm-gc/", 
            "text": "Garbage Collection\n\n\nThe GC module registers with the notification emitter of the\n\nGarbageCollectorMXBean\n\nto provide some basic GC logging and metrics.\n\n\n\n\nGetting started\n\n\nLogging\n\n\nMetrics\n\n\nAlerting\n\n\n\n\nGetting Started\n\n\nFor using it internally at Netflix see the \nNetflix integration\n guide,\notherwise keep reading this section.\n\n\nRequirements\n\n\nThis library relies on the notification emitter added in 7u4, but there are known issues prior\nto 7u40. For G1 it is recommended to be on the latest version available.\n\n\nDependencies\n\n\ncom.netflix.spectator:spectator-ext-gc:0.58.0\n\n\n\n\n\nStart Reporting\n\n\nThen in the initialization for the application:\n\n\nimport\n \ncom.netflix.spectator.gc.GcLogger\n;\n\n\n...\n\n\n// Keep a single instance of the logger\n\n\nGcLogger\n \ngc\n \n=\n \nnew\n \nGcLogger\n();\n\n\ngc\n.\nstart\n(\nnull\n);\n\n\n\n\n\n\nLogging\n\n\nAfter GC events an INFO level log message will get reported using slf4j. This makes it easy to\nGC events in the context of other log messages for the application. The logger name is\n\ncom.netflix.spectator.gc.GcLogger\n and the message will look like:\n\n\n${\nGC_TYPE\n}\n: \n${\nCOLLECTOR_NAME\n}\n, id=\n${\nN\n}\n, at=\n${\nSTART_TIME\n}\n, duration=\n${\nT\n}\nms, cause=[\n${\nCAUSE\n}\n], \n${\nTOTAL_USAGE_BEFORE\n}\n =\n \n${\nTOTAL_USAGE_AFTER\n}\n / \n${\nMAX_SIZE\n}\n (\n${\nPERCENT_USAGE_BEFORE\n}\n =\n \n${\nPERCENT_USAGE_AFTER\n}\n)\n\n\n\n\n\nThe id can be used to verify events were not skipped or correlate with other sources like\ndetailed GC logs. See \nGC causes\n for more details on the possible causes.\n\n\nSample:\n\n\n2014\n-\n08\n-\n31\n \n02\n:\n02\n:\n24\n,\n724\n  \nINFO\n \n[\ncom\n.\nnetflix\n.\nspectator\n.\ngc\n.\nGcLogger\n]\n \nYOUNG\n:\n \nParNew\n,\n \nid\n=\n5281\n,\n \nat\n=\nSun\n \nAug\n \n31\n \n02\n:\n02\n:\n24\n \nUTC\n \n2014\n,\n \nduration\n=\n2\nms\n,\n \ncause\n=\n[\nAllocation\n \nFailure\n],\n \n0.4\nG\n \n=\n \n0.3\nG\n \n/\n \n1.8\nG\n \n(\n24.3\n%\n \n=\n \n16.6\n%\n)\n\n\n\n\n\n\nMetrics\n\n\njvm.gc.allocationRate\n\n\nThe allocation rate measures how fast the application is allocating memory. It is a counter\nthat is incremented after a GC event by the amount \nyoungGen.sizeBeforeGC\n. Technically, right\nnow it is:\n\n\nyoungGen.sizeBeforeGC - youngGen.sizeAfterGC\n\n\nHowever, \nyoungGen.sizeAfterGC\n should be 0 and thus the size of young gen before the GC is\nthe amount allocated since the previous GC event.\n\n\nUnit:\n bytes/second\n\n\nDimensions:\n n/a\n\n\njvm.gc.promotionRate\n\n\nThe promotion rate measures how fast data is being moved from young generation into the old\ngeneration. It is a counter that is incremented after a GC event by the amount:\n\n\nabs(oldGen.sizeAfterGC - oldGen.sizeBeforeGC)\n\n\nUnit:\n bytes/second\n\n\nDimensions:\n n/a\n\n\njvm.gc.liveDataSize\n\n\nThe live data size is the size of the old generation after a major GC. The image below shows\nhow the live data size view compares to a metric showing the current size of the memory pool:\n\n\n\n\nUnit:\n bytes\n\n\nDimensions:\n n/a\n\n\njvm.gc.maxDataSize\n\n\nMaximum size for the old generation. Primary use-case is for gaining perspective on the the\nlive data size.\n\n\nUnit:\n bytes\n\n\nDimensions:\n n/a\n\n\njvm.gc.pause\n\n\nTimer reporting the pause time for a GC event. All of the values reported are stop the world\npauses.\n\n\nUnit:\n\n\n\n\nstatistic=max\n: seconds\n\n\nstatistic=count\n: events/second\n\n\nstatistic=totalTime\n: seconds/second\n\n\n\n\nDimensions:\n\n\n\n\naction\n: action performed by the garbage collector\n   (\njavadoc\n).\n   There is no guarantee, but the typical values seen are \nend_of_major_GC\n and \nend_of_minor_GC\n.\n\n\ncause\n: cause that instigated GC (\njavadoc\n).\n  For an explanation of common causes see the \nGC causes\n page.\n\n\n\n\njvm.gc.concurrentPhaseTime\n\n\nTimer reporting time spent in concurrent phases of CMS.\npauses.\n\n\nUnit:\n\n\n\n\nstatistic=max\n: seconds\n\n\nstatistic=count\n: events/second\n\n\nstatistic=totalTime\n: seconds/second\n\n\n\n\nDimensions:\n\n\n\n\naction\n: action performed by the garbage collector\n  (\njavadoc\n).\n  There is no guarantee, but the typical values seen are \nend_of_major_GC\n and \nend_of_minor_GC\n.\n\n\ncause\n: cause that instigated GC (\njavadoc\n).\n  For an explanation of common causes see the \nGC causes\n page.\n\n\n\n\nAlerting\n\n\nThis section assumes the data is available in \nAtlas\n,\nbut users of other systems should be able to take the idea and make it work. For all of these\nalerts it is recommended to check them on instance. At Netflix that can be done by selecting\nthe option in alert ui:\n\n\n\n\n\n\n\n\nMax Pause Time\n\n\nExample to trigger an alert if the \npause time\n exceeds 500 milliseconds:\n\n\nname,jvm.gc.pause,:eq,\nstatistic,max,:eq,\n:and,\n:max,(,cause,),:by,\n0.5,:gt,\n$cause,:legend\n\n\n\n\n\nHeap Pressure\n\n\nExample to trigger an alert if the \nlive data size\n is over 70% of the heap:\n\n\nname,jvm.gc.liveDataSize,:eq,:max,\nname,jvm.gc.maxDataSize,:eq,:max,\n:div,100,:mul,\n70,:gt,\npercentUsed,:legend", 
            "title": "Garbage Collection"
        }, 
        {
            "location": "/ext/jvm-gc/#garbage-collection", 
            "text": "The GC module registers with the notification emitter of the GarbageCollectorMXBean \nto provide some basic GC logging and metrics.   Getting started  Logging  Metrics  Alerting", 
            "title": "Garbage Collection"
        }, 
        {
            "location": "/ext/jvm-gc/#getting-started", 
            "text": "For using it internally at Netflix see the  Netflix integration  guide,\notherwise keep reading this section.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/ext/jvm-gc/#requirements", 
            "text": "This library relies on the notification emitter added in 7u4, but there are known issues prior\nto 7u40. For G1 it is recommended to be on the latest version available.", 
            "title": "Requirements"
        }, 
        {
            "location": "/ext/jvm-gc/#dependencies", 
            "text": "com.netflix.spectator:spectator-ext-gc:0.58.0", 
            "title": "Dependencies"
        }, 
        {
            "location": "/ext/jvm-gc/#start-reporting", 
            "text": "Then in the initialization for the application:  import   com.netflix.spectator.gc.GcLogger ;  ...  // Keep a single instance of the logger  GcLogger   gc   =   new   GcLogger ();  gc . start ( null );", 
            "title": "Start Reporting"
        }, 
        {
            "location": "/ext/jvm-gc/#logging", 
            "text": "After GC events an INFO level log message will get reported using slf4j. This makes it easy to\nGC events in the context of other log messages for the application. The logger name is com.netflix.spectator.gc.GcLogger  and the message will look like:  ${ GC_TYPE } :  ${ COLLECTOR_NAME } , id= ${ N } , at= ${ START_TIME } , duration= ${ T } ms, cause=[ ${ CAUSE } ],  ${ TOTAL_USAGE_BEFORE }  =   ${ TOTAL_USAGE_AFTER }  /  ${ MAX_SIZE }  ( ${ PERCENT_USAGE_BEFORE }  =   ${ PERCENT_USAGE_AFTER } )  The id can be used to verify events were not skipped or correlate with other sources like\ndetailed GC logs. See  GC causes  for more details on the possible causes.  Sample:  2014 - 08 - 31   02 : 02 : 24 , 724    INFO   [ com . netflix . spectator . gc . GcLogger ]   YOUNG :   ParNew ,   id = 5281 ,   at = Sun   Aug   31   02 : 02 : 24   UTC   2014 ,   duration = 2 ms ,   cause = [ Allocation   Failure ],   0.4 G   =   0.3 G   /   1.8 G   ( 24.3 %   =   16.6 % )", 
            "title": "Logging"
        }, 
        {
            "location": "/ext/jvm-gc/#metrics", 
            "text": "", 
            "title": "Metrics"
        }, 
        {
            "location": "/ext/jvm-gc/#jvmgcallocationrate", 
            "text": "The allocation rate measures how fast the application is allocating memory. It is a counter\nthat is incremented after a GC event by the amount  youngGen.sizeBeforeGC . Technically, right\nnow it is:  youngGen.sizeBeforeGC - youngGen.sizeAfterGC  However,  youngGen.sizeAfterGC  should be 0 and thus the size of young gen before the GC is\nthe amount allocated since the previous GC event.  Unit:  bytes/second  Dimensions:  n/a", 
            "title": "jvm.gc.allocationRate"
        }, 
        {
            "location": "/ext/jvm-gc/#jvmgcpromotionrate", 
            "text": "The promotion rate measures how fast data is being moved from young generation into the old\ngeneration. It is a counter that is incremented after a GC event by the amount:  abs(oldGen.sizeAfterGC - oldGen.sizeBeforeGC)  Unit:  bytes/second  Dimensions:  n/a", 
            "title": "jvm.gc.promotionRate"
        }, 
        {
            "location": "/ext/jvm-gc/#jvmgclivedatasize", 
            "text": "The live data size is the size of the old generation after a major GC. The image below shows\nhow the live data size view compares to a metric showing the current size of the memory pool:   Unit:  bytes  Dimensions:  n/a", 
            "title": "jvm.gc.liveDataSize"
        }, 
        {
            "location": "/ext/jvm-gc/#jvmgcmaxdatasize", 
            "text": "Maximum size for the old generation. Primary use-case is for gaining perspective on the the\nlive data size.  Unit:  bytes  Dimensions:  n/a", 
            "title": "jvm.gc.maxDataSize"
        }, 
        {
            "location": "/ext/jvm-gc/#jvmgcpause", 
            "text": "Timer reporting the pause time for a GC event. All of the values reported are stop the world\npauses.  Unit:   statistic=max : seconds  statistic=count : events/second  statistic=totalTime : seconds/second   Dimensions:   action : action performed by the garbage collector\n   ( javadoc ).\n   There is no guarantee, but the typical values seen are  end_of_major_GC  and  end_of_minor_GC .  cause : cause that instigated GC ( javadoc ).\n  For an explanation of common causes see the  GC causes  page.", 
            "title": "jvm.gc.pause"
        }, 
        {
            "location": "/ext/jvm-gc/#jvmgcconcurrentphasetime", 
            "text": "Timer reporting time spent in concurrent phases of CMS.\npauses.  Unit:   statistic=max : seconds  statistic=count : events/second  statistic=totalTime : seconds/second   Dimensions:   action : action performed by the garbage collector\n  ( javadoc ).\n  There is no guarantee, but the typical values seen are  end_of_major_GC  and  end_of_minor_GC .  cause : cause that instigated GC ( javadoc ).\n  For an explanation of common causes see the  GC causes  page.", 
            "title": "jvm.gc.concurrentPhaseTime"
        }, 
        {
            "location": "/ext/jvm-gc/#alerting", 
            "text": "This section assumes the data is available in  Atlas ,\nbut users of other systems should be able to take the idea and make it work. For all of these\nalerts it is recommended to check them on instance. At Netflix that can be done by selecting\nthe option in alert ui:", 
            "title": "Alerting"
        }, 
        {
            "location": "/ext/jvm-gc/#max-pause-time", 
            "text": "Example to trigger an alert if the  pause time  exceeds 500 milliseconds:  name,jvm.gc.pause,:eq,\nstatistic,max,:eq,\n:and,\n:max,(,cause,),:by,\n0.5,:gt,\n$cause,:legend", 
            "title": "Max Pause Time"
        }, 
        {
            "location": "/ext/jvm-gc/#heap-pressure", 
            "text": "Example to trigger an alert if the  live data size  is over 70% of the heap:  name,jvm.gc.liveDataSize,:eq,:max,\nname,jvm.gc.maxDataSize,:eq,:max,\n:div,100,:mul,\n70,:gt,\npercentUsed,:legend", 
            "title": "Heap Pressure"
        }, 
        {
            "location": "/ext/jvm-gc-causes/", 
            "text": "GC Causes\n\n\nThe various GC causes aren't well documented. The list provided here comes from the\n\ngcCause.cpp\n\nfile in the jdk and we include some information on what these mean for the application.\n\n\nSystem.gc__\n\n\nSomething called \nSystem.gc()\n.\nIf you are seeing this once an hour it is likely related to the RMI GC interval. For more\ndetails see:\n\n\n\n\nUnexplained System.gc() calls due to Remote Method Invocation (RMI) or explict garbage collections\n\n\nsun.rmi.dgc.client.gcInterval\n\n\n\n\nFullGCAlot\n\n\nMost likely you'll never see this value. In debug builds of the jdk there is an option,\n\n-XX:+FullGCALot\n, that will trigger a full GC at a regular interval for testing purposes.\n\n\nScavengeAlot\n\n\nMost likely you'll never see this value. In debug builds of the jdk there is an option,\n\n-XX:+ScavengeALot\n, that will trigger a minor GC at a regular interval for testing purposes.\n\n\nAllocation_Profiler\n\n\nPrior to java 8 you would see this if running with the \n-Xaprof\n setting. It would be triggered\njust before the jvm exits. The \n-Xaprof\n option was removed in java 8.\n\n\nJvmtiEnv_ForceGarbageCollection\n\n\nSomething called the JVM tool interface function\n\nForceGarbageCollection\n.\nLook at the \n-agentlib\n param to java to see what agents are configured.\n\n\nGCLocker_Initiated_GC\n\n\nThe GC locker prevents GC from occurring when JNI code is in a\n\ncritical region\n.\nIf GC is needed while a thread is in a critical region, then it will allow them to complete,\ni.e. call the corresponding release function. Other threads will not be permitted to enter a\ncritical region. Once all threads are out of critical regions a GC event will be triggered. \n\n\nHeap_Inspection_Initiated_GC\n\n\nGC was initiated by an inspection operation on the heap. For example you can trigger this\nwith \njmap\n:\n\n\n$ jmap -histo:live \npid\n\n\nHeap_Dump_Initiated_GC\n\n\nGC was initiated before dumping the heap. For example you can trigger this with\n\njmap\n:\n\n\n$ jmap -dump:live,format=b,file=heap.out \npid\n\n\nAnother common example would be clicking the Heap Dump button on the Monitor tab in\n\njvisualvm\n.\n\n\nWhiteBox_Initiated_Young_GC\n\n\nMost likely you'll never see this value. Used for testing hotspot, it indicates something\ncalled \nsun.hotspot.WhiteBox.youngGC()\n. \n\n\nNo_GC\n\n\nUsed for CMS to indicate concurrent phases.\n\n\nAllocation_Failure\n\n\nUsually this means that there is an allocation request that is bigger than the available space\nin young generation and will typically be associated with a minor GC. For G1 this will likely\nbe a major GC and it is more common to see \nG1_Evacuation_Pause\n for\nroutine minor collections.\n\n\nOn linux the jvm will trigger a GC if the kernel indicates there isn't much memory left via\n\nmem_notify\n.\n\n\nTenured_Generation_Full\n\n\nNot used?\n\n\nPermanent_Generation_Full\n\n\nTriggered as a result of an allocation failure in\n\nPermGen\n. Pre java 8.\n\n\nMetadata_GC_Threshold\n\n\nTriggered as a result of an allocation failure in\n\nMetaspace\n.\nMetaspace replaced PermGen was added in java 8.\n\n\nCMS_Generation_Full\n\n\nNot used?\n\n\nCMS_Initial_Mark\n\n\nInitial mark phase of CMS, for more details see\n\nPhases of CMS\n.\nUnfortunately it doesn't appear to be reported via the mbeans and we just get \nNo_GC\n.\n\n\nCMS_Final_Remark\n\n\nRemark phase of CMS, for more details see\n\nPhases of CMS\n.\nUnfortunately it doesn't appear to be reported via the mbeans and we just get \nNo_GC\n.\n\n\nCMS_Concurrent_Mark\n\n\nConcurrent mark phase of CMS, for more details see\n\nPhases of CMS\n.\nUnfortunately it doesn't appear to be reported via the mbeans and we just get \nNo_GC\n.\n\n\nOld_Generation_Expanded_On_Last_Scavenge\n\n\nNot used?\n\n\nOld_Generation_Too_Full_To_Scavenge\n\n\nNot used?\n\n\nErgonomics\n\n\nThis indicates you are using the adaptive size policy, \n-XX:+UseAdaptiveSizePolicy\n and is\non by default for recent versions, with the parallel collector (\n-XX:+UseParallelGC\n). For\nmore details see \nThe Why of GC Ergonomics\n.\n\n\nG1_Evacuation_Pause\n\n\nAn evacuation pause is the most common young gen cause for G1 and indicates that it is copying\nlive objects from one set of regions, young and sometimes young + old, to another set of\nregions. For more details see \nUnderstanding G1 GC Logs\n.\n\n\nG1_Humongous_Allocation\n\n\nA humongous allocation is one where the size is greater than 50% of the G1 region size. Before\na humongous allocation the jvm checks if it should do a routine\n\nevacuation pause\n without regard to the actual allocation size, but if\ntriggered due to this check the cause will be listed as humongous allocation. This cause is\nalso used for any collections used to free up enough space for the allocation. \n\n\nLast_ditch_collection\n\n\nFor perm gen (java 7 or earlier) and metaspace (java 8+) a last ditch collection will be\ntriggered if an allocation fails and the memory pool cannot be expanded.\n\n\nILLEGAL_VALUE_-\nlast_gc_cause\n-_ILLEGAL_VALUE\n\n\nIncluded for completeness, but you should never see this value.\n\n\nunknown_GCCause\n\n\nIncluded for completeness, but you should never see this value.", 
            "title": "GC Causes"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#gc-causes", 
            "text": "The various GC causes aren't well documented. The list provided here comes from the gcCause.cpp \nfile in the jdk and we include some information on what these mean for the application.", 
            "title": "GC Causes"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#systemgc__", 
            "text": "Something called  System.gc() .\nIf you are seeing this once an hour it is likely related to the RMI GC interval. For more\ndetails see:   Unexplained System.gc() calls due to Remote Method Invocation (RMI) or explict garbage collections  sun.rmi.dgc.client.gcInterval", 
            "title": "System.gc__"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#fullgcalot", 
            "text": "Most likely you'll never see this value. In debug builds of the jdk there is an option, -XX:+FullGCALot , that will trigger a full GC at a regular interval for testing purposes.", 
            "title": "FullGCAlot"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#scavengealot", 
            "text": "Most likely you'll never see this value. In debug builds of the jdk there is an option, -XX:+ScavengeALot , that will trigger a minor GC at a regular interval for testing purposes.", 
            "title": "ScavengeAlot"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#allocation_profiler", 
            "text": "Prior to java 8 you would see this if running with the  -Xaprof  setting. It would be triggered\njust before the jvm exits. The  -Xaprof  option was removed in java 8.", 
            "title": "Allocation_Profiler"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#jvmtienv_forcegarbagecollection", 
            "text": "Something called the JVM tool interface function ForceGarbageCollection .\nLook at the  -agentlib  param to java to see what agents are configured.", 
            "title": "JvmtiEnv_ForceGarbageCollection"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#gclocker_initiated_gc", 
            "text": "The GC locker prevents GC from occurring when JNI code is in a critical region .\nIf GC is needed while a thread is in a critical region, then it will allow them to complete,\ni.e. call the corresponding release function. Other threads will not be permitted to enter a\ncritical region. Once all threads are out of critical regions a GC event will be triggered.", 
            "title": "GCLocker_Initiated_GC"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#heap_inspection_initiated_gc", 
            "text": "GC was initiated by an inspection operation on the heap. For example you can trigger this\nwith  jmap :  $ jmap -histo:live  pid", 
            "title": "Heap_Inspection_Initiated_GC"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#heap_dump_initiated_gc", 
            "text": "GC was initiated before dumping the heap. For example you can trigger this with jmap :  $ jmap -dump:live,format=b,file=heap.out  pid  Another common example would be clicking the Heap Dump button on the Monitor tab in jvisualvm .", 
            "title": "Heap_Dump_Initiated_GC"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#whitebox_initiated_young_gc", 
            "text": "Most likely you'll never see this value. Used for testing hotspot, it indicates something\ncalled  sun.hotspot.WhiteBox.youngGC() .", 
            "title": "WhiteBox_Initiated_Young_GC"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#no_gc", 
            "text": "Used for CMS to indicate concurrent phases.", 
            "title": "No_GC"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#allocation_failure", 
            "text": "Usually this means that there is an allocation request that is bigger than the available space\nin young generation and will typically be associated with a minor GC. For G1 this will likely\nbe a major GC and it is more common to see  G1_Evacuation_Pause  for\nroutine minor collections.  On linux the jvm will trigger a GC if the kernel indicates there isn't much memory left via mem_notify .", 
            "title": "Allocation_Failure"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#tenured_generation_full", 
            "text": "Not used?", 
            "title": "Tenured_Generation_Full"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#permanent_generation_full", 
            "text": "Triggered as a result of an allocation failure in PermGen . Pre java 8.", 
            "title": "Permanent_Generation_Full"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#metadata_gc_threshold", 
            "text": "Triggered as a result of an allocation failure in Metaspace .\nMetaspace replaced PermGen was added in java 8.", 
            "title": "Metadata_GC_Threshold"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#cms_generation_full", 
            "text": "Not used?", 
            "title": "CMS_Generation_Full"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#cms_initial_mark", 
            "text": "Initial mark phase of CMS, for more details see Phases of CMS .\nUnfortunately it doesn't appear to be reported via the mbeans and we just get  No_GC .", 
            "title": "CMS_Initial_Mark"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#cms_final_remark", 
            "text": "Remark phase of CMS, for more details see Phases of CMS .\nUnfortunately it doesn't appear to be reported via the mbeans and we just get  No_GC .", 
            "title": "CMS_Final_Remark"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#cms_concurrent_mark", 
            "text": "Concurrent mark phase of CMS, for more details see Phases of CMS .\nUnfortunately it doesn't appear to be reported via the mbeans and we just get  No_GC .", 
            "title": "CMS_Concurrent_Mark"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#old_generation_expanded_on_last_scavenge", 
            "text": "Not used?", 
            "title": "Old_Generation_Expanded_On_Last_Scavenge"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#old_generation_too_full_to_scavenge", 
            "text": "Not used?", 
            "title": "Old_Generation_Too_Full_To_Scavenge"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#ergonomics", 
            "text": "This indicates you are using the adaptive size policy,  -XX:+UseAdaptiveSizePolicy  and is\non by default for recent versions, with the parallel collector ( -XX:+UseParallelGC ). For\nmore details see  The Why of GC Ergonomics .", 
            "title": "Ergonomics"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#g1_evacuation_pause", 
            "text": "An evacuation pause is the most common young gen cause for G1 and indicates that it is copying\nlive objects from one set of regions, young and sometimes young + old, to another set of\nregions. For more details see  Understanding G1 GC Logs .", 
            "title": "G1_Evacuation_Pause"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#g1_humongous_allocation", 
            "text": "A humongous allocation is one where the size is greater than 50% of the G1 region size. Before\na humongous allocation the jvm checks if it should do a routine evacuation pause  without regard to the actual allocation size, but if\ntriggered due to this check the cause will be listed as humongous allocation. This cause is\nalso used for any collections used to free up enough space for the allocation.", 
            "title": "G1_Humongous_Allocation"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#last_ditch_collection", 
            "text": "For perm gen (java 7 or earlier) and metaspace (java 8+) a last ditch collection will be\ntriggered if an allocation fails and the memory pool cannot be expanded.", 
            "title": "Last_ditch_collection"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#illegal_value_-last_gc_cause-_illegal_value", 
            "text": "Included for completeness, but you should never see this value.", 
            "title": "ILLEGAL_VALUE_-last_gc_cause-_ILLEGAL_VALUE"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#unknown_gccause", 
            "text": "Included for completeness, but you should never see this value.", 
            "title": "unknown_GCCause"
        }, 
        {
            "location": "/ext/jvm-memory-pools/", 
            "text": "Memory Pools\n\n\nUses the \nMemoryPoolMXBean\n\nprovided by the JDK to monitor the sizes of java memory spaces such as perm gen, eden, old\ngen, etc. \n\n\nGetting Started\n\n\nTo get information about memory pools in spectator just setup registration of standard MXBeans.\nNote, if you are building an app at Netflix this should happen automatically via the normal\nplatform initialization.\n\n\nimport\n \ncom.netflix.spectator.api.Spectator\n;\n\n\nimport\n \ncom.netflix.spectator.jvm.Jmx\n;\n\n\n\nJmx\n.\nregisterStandardMXBeans\n(\nSpectator\n.\nregistry\n());\n\n\n\n\n\n\nMetrics\n\n\njvm.memory.used\n\n\nGauge reporting the current amount of memory used. For the young and old gen pools this\nmetric will typically have a sawtooth pattern. For alerting or detecting memory pressure\nthe \nlive data size\n\nis probably a better option.\n\n\nUnit:\n bytes\n\n\nDimensions:\n\nsee \nmetric dimensions\n\n\njvm.memory.committed\n\n\nGauge reporting the current amount of memory committed. From the\n\njavadocs\n,\ncommitted is:\n\n\n\n\nThe amount of memory (in bytes) that is guaranteed to be available for use by the Java\nvirtual machine. The amount of committed memory may change over time (increase or decrease).\nThe Java virtual machine may release memory to the system and committed could be less than\ninit. committed will always be greater than or equal to used.\n\n\n\n\nUnit:\n bytes \n\n\nDimensions:\n\nsee \nmetric dimensions\n\n\njvm.memory.max\n\n\nGauge reporting the max amount of memory that can be used. From the\n\njavadocs\n,\nmax is:\n\n\n\n\nThe maximum amount of memory (in bytes) that can be used for memory management. Its value\nmay be undefined. The maximum amount of memory may change over time if defined. The amount\nof used and committed memory will always be less than or equal to max if max is defined. A\nmemory allocation may fail if it attempts to increase the used memory such that\n\nused \n committed\n even if \nused \n= max\n would still be true (for example, when the\nsystem is low on virtual memory).\n\n\n\n\nUnit:\n bytes \n\n\nDimensions:\n\nsee \nmetric dimensions\n\n\nMetric Dimensions\n\n\nAll memory metrics have the following dimensions:\n\n\n\n\nid\n: name of the memory pool being reported. The names of the pools vary depending on the\n  garbage collector algorithm being used.\n\n\nmemtype\n: type of memory. It has two possible values: \nHEAP\n and \nNON_HEAP\n. For more\n  information see the javadocs for \nMemoryType\n.", 
            "title": "Memory Pools"
        }, 
        {
            "location": "/ext/jvm-memory-pools/#memory-pools", 
            "text": "Uses the  MemoryPoolMXBean \nprovided by the JDK to monitor the sizes of java memory spaces such as perm gen, eden, old\ngen, etc.", 
            "title": "Memory Pools"
        }, 
        {
            "location": "/ext/jvm-memory-pools/#getting-started", 
            "text": "To get information about memory pools in spectator just setup registration of standard MXBeans.\nNote, if you are building an app at Netflix this should happen automatically via the normal\nplatform initialization.  import   com.netflix.spectator.api.Spectator ;  import   com.netflix.spectator.jvm.Jmx ;  Jmx . registerStandardMXBeans ( Spectator . registry ());", 
            "title": "Getting Started"
        }, 
        {
            "location": "/ext/jvm-memory-pools/#metrics", 
            "text": "", 
            "title": "Metrics"
        }, 
        {
            "location": "/ext/jvm-memory-pools/#jvmmemoryused", 
            "text": "Gauge reporting the current amount of memory used. For the young and old gen pools this\nmetric will typically have a sawtooth pattern. For alerting or detecting memory pressure\nthe  live data size \nis probably a better option.  Unit:  bytes  Dimensions: \nsee  metric dimensions", 
            "title": "jvm.memory.used"
        }, 
        {
            "location": "/ext/jvm-memory-pools/#jvmmemorycommitted", 
            "text": "Gauge reporting the current amount of memory committed. From the javadocs ,\ncommitted is:   The amount of memory (in bytes) that is guaranteed to be available for use by the Java\nvirtual machine. The amount of committed memory may change over time (increase or decrease).\nThe Java virtual machine may release memory to the system and committed could be less than\ninit. committed will always be greater than or equal to used.   Unit:  bytes   Dimensions: \nsee  metric dimensions", 
            "title": "jvm.memory.committed"
        }, 
        {
            "location": "/ext/jvm-memory-pools/#jvmmemorymax", 
            "text": "Gauge reporting the max amount of memory that can be used. From the javadocs ,\nmax is:   The maximum amount of memory (in bytes) that can be used for memory management. Its value\nmay be undefined. The maximum amount of memory may change over time if defined. The amount\nof used and committed memory will always be less than or equal to max if max is defined. A\nmemory allocation may fail if it attempts to increase the used memory such that used   committed  even if  used  = max  would still be true (for example, when the\nsystem is low on virtual memory).   Unit:  bytes   Dimensions: \nsee  metric dimensions", 
            "title": "jvm.memory.max"
        }, 
        {
            "location": "/ext/jvm-memory-pools/#metric-dimensions", 
            "text": "All memory metrics have the following dimensions:   id : name of the memory pool being reported. The names of the pools vary depending on the\n  garbage collector algorithm being used.  memtype : type of memory. It has two possible values:  HEAP  and  NON_HEAP . For more\n  information see the javadocs for  MemoryType .", 
            "title": "Metric Dimensions"
        }, 
        {
            "location": "/ext/thread-pools/", 
            "text": "Thread Pools\n\n\nJava's \nThreadPoolExecutor\n exposes several properties that are useful to monitor to assess\nthe health, performance, and configuration of the pool.\n\n\nGetting Started\n\n\nTo report thread pool metrics, one can attach a \nThreadPoolMonitor\n in the following manner:\n\n\nimport\n \ncom.netflix.spectator.api.patterns.ThreadPoolMonitor\n;\n\n\n\nThreadPoolMonitor\n.\nattach\n(\nregistry\n,\n \nmyThreadPoolExecutor\n,\n \nmy-thread-pool\n);\n\n\n\n\n\n\nThe thread pool's properties will be polled regularly in the background and will report metrics to the provided\nregistry. The third parameter will be added to each metric as an \nid\n dimension, if provided. However, if the value is\n\nnull\n or an empty string, then a default will be used as the \nid\n.\n\n\nMetrics\n\n\nthreadpool.taskCount\n\n\nCounter of the total number of tasks that have been scheduled.\n\n\nUnit:\n tasks/second\n\n\nData Source:\n \nThreadPoolExecutor#getTaskCount()\n\n\nthreadpool.completedTaskCount\n\n\nCounter of the total number of tasks that have completed.\n\n\nUnit:\n tasks/second\n\n\nData Source:\n \nThreadPoolExecutor#getCompletedTaskCount()\n\n\nthreadpool.currentThreadsBusy\n\n\nGauge showing the current number of threads actively doing work.\n\n\nUnit:\n count\n\n\nData Source:\n \nThreadPoolExecutor#getActiveCount()\n\n\nthreadpool.maxThreads\n\n\nGauge showing the current maximum number of threads configured for the pool.\n\n\nUnit:\n count\n\n\nData Source:\n \nThreadPoolExecutor#getMaximumPoolSize()\n\n\nthreadpool.poolSize\n\n\nGauge showing the current size of the pool.\n\n\nUnit:\n count\n\n\nData Source:\n \nThreadPoolExecutor#getPoolSize()\n\n\nthreadpool.corePoolSize\n\n\nGauge showing the current maximum number of core threads configured for the pool.\n\n\nUnit:\n count\n\n\nData Source:\n \nThreadPoolExecutor#getCorePoolSize()\n\n\nthreadpool.queueSize\n\n\nGauge showing the current number of threads queued for execution.\n\n\nUnit:\n count\n\n\nData Source:\n \nThreadPoolExecutor#getQueue().size()", 
            "title": "Thread Pools"
        }, 
        {
            "location": "/ext/thread-pools/#thread-pools", 
            "text": "Java's  ThreadPoolExecutor  exposes several properties that are useful to monitor to assess\nthe health, performance, and configuration of the pool.", 
            "title": "Thread Pools"
        }, 
        {
            "location": "/ext/thread-pools/#getting-started", 
            "text": "To report thread pool metrics, one can attach a  ThreadPoolMonitor  in the following manner:  import   com.netflix.spectator.api.patterns.ThreadPoolMonitor ;  ThreadPoolMonitor . attach ( registry ,   myThreadPoolExecutor ,   my-thread-pool );   The thread pool's properties will be polled regularly in the background and will report metrics to the provided\nregistry. The third parameter will be added to each metric as an  id  dimension, if provided. However, if the value is null  or an empty string, then a default will be used as the  id .", 
            "title": "Getting Started"
        }, 
        {
            "location": "/ext/thread-pools/#metrics", 
            "text": "", 
            "title": "Metrics"
        }, 
        {
            "location": "/ext/thread-pools/#threadpooltaskcount", 
            "text": "Counter of the total number of tasks that have been scheduled.  Unit:  tasks/second  Data Source:   ThreadPoolExecutor#getTaskCount()", 
            "title": "threadpool.taskCount"
        }, 
        {
            "location": "/ext/thread-pools/#threadpoolcompletedtaskcount", 
            "text": "Counter of the total number of tasks that have completed.  Unit:  tasks/second  Data Source:   ThreadPoolExecutor#getCompletedTaskCount()", 
            "title": "threadpool.completedTaskCount"
        }, 
        {
            "location": "/ext/thread-pools/#threadpoolcurrentthreadsbusy", 
            "text": "Gauge showing the current number of threads actively doing work.  Unit:  count  Data Source:   ThreadPoolExecutor#getActiveCount()", 
            "title": "threadpool.currentThreadsBusy"
        }, 
        {
            "location": "/ext/thread-pools/#threadpoolmaxthreads", 
            "text": "Gauge showing the current maximum number of threads configured for the pool.  Unit:  count  Data Source:   ThreadPoolExecutor#getMaximumPoolSize()", 
            "title": "threadpool.maxThreads"
        }, 
        {
            "location": "/ext/thread-pools/#threadpoolpoolsize", 
            "text": "Gauge showing the current size of the pool.  Unit:  count  Data Source:   ThreadPoolExecutor#getPoolSize()", 
            "title": "threadpool.poolSize"
        }, 
        {
            "location": "/ext/thread-pools/#threadpoolcorepoolsize", 
            "text": "Gauge showing the current maximum number of core threads configured for the pool.  Unit:  count  Data Source:   ThreadPoolExecutor#getCorePoolSize()", 
            "title": "threadpool.corePoolSize"
        }, 
        {
            "location": "/ext/thread-pools/#threadpoolqueuesize", 
            "text": "Gauge showing the current number of threads queued for execution.  Unit:  count  Data Source:   ThreadPoolExecutor#getQueue().size()", 
            "title": "threadpool.queueSize"
        }, 
        {
            "location": "/ext/log4j2/", 
            "text": "Log4j2 Appender\n\n\nCustom appender for \nlog4j2\n to track the number of\nlog messages reported. \n\n\nGetting Started\n\n\nTo use it simply add a dependency:\n\n\ncom.netflix.spectator:spectator-ext-log4j2:0.58.0\n\n\n\n\n\nThen in your application initialization:\n\n\nRegistry\n \nregistry\n \n=\n \n...\n\n\nSpectatorAppender\n.\naddToRootLogger\n(\n\n    \nregistry\n,\n             \n// Registry to use\n\n    \nspectator\n,\n          \n// Name for the appender\n\n    \nfalse\n);\n               \n// Should stack traces be ignored?\n\n\n\n\n\n\nThis will add the appender to the root logger and register a listener so it will get\nre-added if the configuration changes. You can also use the appender by specifying it\nin the log4j2 configuration, but this will cause some of the loggers in Spectator to get\ncreated before log4j is properly initialized and result in some lost log messages. With\nthat caveat in mind, if you need the additional flexibility of using the configuration then\nspecify the \nSpectator\n appender:\n\n\n?xml version=\n1.0\n encoding=\nUTF-8\n?\n\n\nConfiguration\n \nmonitorInterval=\n5\n \nstatus=\nwarn\n\n  \nAppenders\n\n    \nSpectator\n \nname=\nroot\n/\n\n  \n/Appenders\n\n  \nLoggers\n\n    \nRoot\n \nlevel=\ndebug\n\n      \nAppenderRef\n \nref=\nroot\n/\n\n    \n/Root\n\n  \n/Loggers\n\n\n/Configuration\n\n\n\n\n\n\nMetrics\n\n\nlog4j.numMessages\n\n\nCounters showing the number of messages that have been passed to the appender.\n\n\nUnit:\n messages/second\n\n\nDimensions:\n\n\n\n\nappender\n: name of the spectator appender.\n\n\nloglevel\n: standard log level of the events.\n\n\n\n\nlog4j.numStackTraces\n\n\nCounter for the number of messages with stack traces written to the logs. This will only be\ncollected if the \nignoreExceptions\n flag is set to false for the appender.\n\n\nUnit:\n messages/second\n\n\nDimensions:\n\n\n\n\nappender\n: name of the spectator appender.\n\n\nloglevel\n: standard log level of the events.\n\n\nexception\n: simple class name for the exception that was thrown.\n\n\nfile\n: file name for where the exception was thrown.", 
            "title": "Log4j2 Appender"
        }, 
        {
            "location": "/ext/log4j2/#log4j2-appender", 
            "text": "Custom appender for  log4j2  to track the number of\nlog messages reported.", 
            "title": "Log4j2 Appender"
        }, 
        {
            "location": "/ext/log4j2/#getting-started", 
            "text": "To use it simply add a dependency:  com.netflix.spectator:spectator-ext-log4j2:0.58.0  Then in your application initialization:  Registry   registry   =   ...  SpectatorAppender . addToRootLogger ( \n     registry ,               // Registry to use \n     spectator ,            // Name for the appender \n     false );                 // Should stack traces be ignored?   This will add the appender to the root logger and register a listener so it will get\nre-added if the configuration changes. You can also use the appender by specifying it\nin the log4j2 configuration, but this will cause some of the loggers in Spectator to get\ncreated before log4j is properly initialized and result in some lost log messages. With\nthat caveat in mind, if you need the additional flexibility of using the configuration then\nspecify the  Spectator  appender:  ?xml version= 1.0  encoding= UTF-8 ?  Configuration   monitorInterval= 5   status= warn \n   Appenders \n     Spectator   name= root / \n   /Appenders \n   Loggers \n     Root   level= debug \n       AppenderRef   ref= root / \n     /Root \n   /Loggers  /Configuration", 
            "title": "Getting Started"
        }, 
        {
            "location": "/ext/log4j2/#metrics", 
            "text": "", 
            "title": "Metrics"
        }, 
        {
            "location": "/ext/log4j2/#log4jnummessages", 
            "text": "Counters showing the number of messages that have been passed to the appender.  Unit:  messages/second  Dimensions:   appender : name of the spectator appender.  loglevel : standard log level of the events.", 
            "title": "log4j.numMessages"
        }, 
        {
            "location": "/ext/log4j2/#log4jnumstacktraces", 
            "text": "Counter for the number of messages with stack traces written to the logs. This will only be\ncollected if the  ignoreExceptions  flag is set to false for the appender.  Unit:  messages/second  Dimensions:   appender : name of the spectator appender.  loglevel : standard log level of the events.  exception : simple class name for the exception that was thrown.  file : file name for where the exception was thrown.", 
            "title": "log4j.numStackTraces"
        }, 
        {
            "location": "/ext/log4j1/", 
            "text": "Log4j1 Appender\n\n\nCustom appender for \nlog4j1\n to track the number of\nlog messages reported. \n\n\n\n\nNote\n\n\nLog4j 1.x has reached \nend of life\n and is no longer supported by Apache. This extension\nis provided for some users that have difficulty moving to a supported version of log4j.\n\n\n\n\nGetting Started\n\n\nTo use it simply add a dependency:\n\n\ncom.netflix.spectator:spectator-ext-log4j1:0.58.0\n\n\n\n\n\nThen in your log4j configuration specify the \ncom.netflix.spectator.log4j.SpectatorAppender\n.\nIn a properties file it would look something like:\n\n\nlog4j.rootLogger=ALL, A1\nlog4j.appender.A1=com.netflix.spectator.log4j.SpectatorAppender\n\n\n\n\n\nMetrics\n\n\nlog4j.numMessages\n\n\nCounters showing the number of messages that have been passed to the appender.\n\n\nUnit:\n messages/second\n\n\nDimensions:\n\n\n\n\nloglevel\n: standard log level of the events.\n\n\n\n\nlog4j.numStackTraces\n\n\nCounter for the number of messages with stack traces written to the logs.\n\n\nUnit:\n messages/second\n\n\nDimensions:\n\n\n\n\nloglevel\n: standard log level of the events.\n\n\nexception\n: simple class name for the exception that was thrown.\n\n\nfile\n: file name for where the exception was thrown.", 
            "title": "Log4j1 Appender"
        }, 
        {
            "location": "/ext/log4j1/#log4j1-appender", 
            "text": "Custom appender for  log4j1  to track the number of\nlog messages reported.    Note  Log4j 1.x has reached  end of life  and is no longer supported by Apache. This extension\nis provided for some users that have difficulty moving to a supported version of log4j.", 
            "title": "Log4j1 Appender"
        }, 
        {
            "location": "/ext/log4j1/#getting-started", 
            "text": "To use it simply add a dependency:  com.netflix.spectator:spectator-ext-log4j1:0.58.0  Then in your log4j configuration specify the  com.netflix.spectator.log4j.SpectatorAppender .\nIn a properties file it would look something like:  log4j.rootLogger=ALL, A1\nlog4j.appender.A1=com.netflix.spectator.log4j.SpectatorAppender", 
            "title": "Getting Started"
        }, 
        {
            "location": "/ext/log4j1/#metrics", 
            "text": "", 
            "title": "Metrics"
        }, 
        {
            "location": "/ext/log4j1/#log4jnummessages", 
            "text": "Counters showing the number of messages that have been passed to the appender.  Unit:  messages/second  Dimensions:   loglevel : standard log level of the events.", 
            "title": "log4j.numMessages"
        }, 
        {
            "location": "/ext/log4j1/#log4jnumstacktraces", 
            "text": "Counter for the number of messages with stack traces written to the logs.  Unit:  messages/second  Dimensions:   loglevel : standard log level of the events.  exception : simple class name for the exception that was thrown.  file : file name for where the exception was thrown.", 
            "title": "log4j.numStackTraces"
        }, 
        {
            "location": "/ext/placeholders/", 
            "text": "Placeholders\n\n\nThe placeholders extension allows for identifiers to be created with dimensions that\nwill get filled in based on the context when an activity occurs. The primary use-cases\nare to support:\n\n\n\n\nOptional dimensions that can be conditionally enabled.\n\n\nPulling dimensions from another context such as a thread local store. This can make\n   it is easier to share the across various parts of the code.\n\n\n\n\nDependencies\n\n\nTo use the placeholders support add a dependency on:\n\n\ncom.netflix.spectator:spectator-ext-placeholders:0.58.0\n\n\n\n\n\nUsage\n\n\nPlaceholder support is available for activity based types including\n\ncounters\n, \ntimers\n, and\n\ndistribution summaries\n. To get started create a\n\nPlaceholderFactory\n from the registry:\n\n\nPlaceholderFactory\n \nfactory\n \n=\n \nPlaceholderFactory\n.\nfrom\n(\nregistry\n);\n\n\n\n\n\n\nThen use the factory to create an identifier using a \nTagFactory\n to dynamically fetch\nthe value for a given dimension when some activity occurs. Suppose we want to use a\ndynamic configuration library such as \nArchaius\n\nto conditionally enable a dimension with high cardinality:\n\n\npublic\n \nclass\n \nServer\n \n{\n\n\n  \nprivate\n \nfinal\n \nContext\n \ncontext\n;\n\n  \nprivate\n \nfinal\n \nCounter\n \nrps\n;\n\n\n  \npublic\n \nServer\n(\nContext\n \ncontext\n,\n \nPropertyFactory\n \nprops\n,\n \nRegistry\n \nregistry\n)\n \n{\n\n    \nthis\n.\ncontext\n \n=\n \ncontext\n;\n\n\n    \n// Property that can be dynamically updated to indicate whether or not\n\n    \n// detailed dimensions should be added to metrics.\n\n    \nProperty\nBoolean\n \nenabled\n \n=\n \nprops\n\n      \n.\ngetProperty\n(\nserver.detailedMetricsEnabled\n)\n\n      \n.\nasBoolean\n(\nfalse\n);\n\n\n    \n// Factory for creating instances of the counter using placeholders\n\n    \nPlaceholderFactory\n \nfactory\n \n=\n \nPlaceholderFactory\n.\nfrom\n(\nregistry\n);\n\n\n    \n// Create the underlying id with 4 possible dimensions:\n\n    \n// *  method and status - low cardinality and always added if available\n\n    \n//    in the context.\n\n    \n// *  geo and device - high cardinality and only available if the property\n\n    \n//    to enable detailed metrics is set to true.\n\n    \nPlaceholderId\n \nrpsId\n \n=\n \nfactory\n.\ncreateId\n(\nserver.requests\n)\n\n      \n.\nwithTagFactory\n(\nTagFactory\n.\nfrom\n(\nmethod\n,\n \ncontext\n::\ngetMethod\n))\n\n      \n.\nwithTagFactory\n(\nTagFactory\n.\nfrom\n(\nstatus\n,\n \ncontext\n::\ngetStatus\n))\n\n      \n.\nwithTagFactory\n(\nnew\n \nDetailedDimension\n(\ngeo\n,\n \nenabled\n,\n \ncontext\n::\ngetGeo\n))\n\n      \n.\nwithTagFactory\n(\nnew\n \nDetailedDimension\n(\ndevice\n,\n \nenabled\n,\n \ncontext\n::\ngetDevice\n));\n\n    \nrps\n \n=\n \nfactory\n.\ncounter\n(\nrpsId\n);\n\n  \n}\n\n\n  \npublic\n \nResponse\n \nhandle\n(\nRequest\n \nrequest\n)\n \n{\n\n    \nfillInContext\n(\nrequest\n);\n\n    \nResponse\n \nresponse\n \n=\n \nprocess\n(\nrequest\n);\n\n    \nfillInContext\n(\nresponse\n);\n\n\n    \n// Update the counter, the placeholders will be resolved when the activity, in\n\n    \n// this case the increment is called.\n\n    \nrps\n.\nincrement\n();\n\n    \nreturn\n \nresponse\n;\n\n  \n}\n\n\n  \n// Tag factory that can be controlled with an enabled property.\n\n  \nprivate\n \nstatic\n \nclass\n \nDetailedDimension\n \nimplements\n \nTagFactory\n \n{\n\n\n    \nprivate\n \nfinal\n \nString\n \nname\n;\n\n    \nprivate\n \nfinal\n \nSupplier\nString\n \nvalueFunc\n;\n\n\n    \nDetailedDimension\n(\nString\n \nname\n,\n \nProperty\nBoolean\n \nenabled\n,\n \nSupplier\nString\n \nvalueFunc\n)\n \n{\n\n      \nthis\n.\nname\n \n=\n \nname\n;\n\n      \nthis\n.\nenabled\n \n=\n \nenabled\n;\n\n      \nthis\n.\nvalueFunc\n \n=\n \nvalueFunc\n;\n\n    \n}\n\n\n    \n@Override\n \npublic\n \nString\n \nname\n()\n \n{\n\n      \nreturn\n \nname\n;\n\n    \n}\n\n\n    \n@Override\n \npublic\n \nTag\n \ncreateTag\n()\n \n{\n\n      \nreturn\n \nenabled\n.\nget\n()\n\n          \n?\n \nnew\n \nBasicTag\n(\nname\n,\n \nvalueFunc\n.\nget\n())\n\n          \n:\n \nnull\n;\n\n    \n}\n\n  \n}\n\n\n}", 
            "title": "Placeholders"
        }, 
        {
            "location": "/ext/placeholders/#placeholders", 
            "text": "The placeholders extension allows for identifiers to be created with dimensions that\nwill get filled in based on the context when an activity occurs. The primary use-cases\nare to support:   Optional dimensions that can be conditionally enabled.  Pulling dimensions from another context such as a thread local store. This can make\n   it is easier to share the across various parts of the code.", 
            "title": "Placeholders"
        }, 
        {
            "location": "/ext/placeholders/#dependencies", 
            "text": "To use the placeholders support add a dependency on:  com.netflix.spectator:spectator-ext-placeholders:0.58.0", 
            "title": "Dependencies"
        }, 
        {
            "location": "/ext/placeholders/#usage", 
            "text": "Placeholder support is available for activity based types including counters ,  timers , and distribution summaries . To get started create a PlaceholderFactory  from the registry:  PlaceholderFactory   factory   =   PlaceholderFactory . from ( registry );   Then use the factory to create an identifier using a  TagFactory  to dynamically fetch\nthe value for a given dimension when some activity occurs. Suppose we want to use a\ndynamic configuration library such as  Archaius \nto conditionally enable a dimension with high cardinality:  public   class   Server   { \n\n   private   final   Context   context ; \n   private   final   Counter   rps ; \n\n   public   Server ( Context   context ,   PropertyFactory   props ,   Registry   registry )   { \n     this . context   =   context ; \n\n     // Property that can be dynamically updated to indicate whether or not \n     // detailed dimensions should be added to metrics. \n     Property Boolean   enabled   =   props \n       . getProperty ( server.detailedMetricsEnabled ) \n       . asBoolean ( false ); \n\n     // Factory for creating instances of the counter using placeholders \n     PlaceholderFactory   factory   =   PlaceholderFactory . from ( registry ); \n\n     // Create the underlying id with 4 possible dimensions: \n     // *  method and status - low cardinality and always added if available \n     //    in the context. \n     // *  geo and device - high cardinality and only available if the property \n     //    to enable detailed metrics is set to true. \n     PlaceholderId   rpsId   =   factory . createId ( server.requests ) \n       . withTagFactory ( TagFactory . from ( method ,   context :: getMethod )) \n       . withTagFactory ( TagFactory . from ( status ,   context :: getStatus )) \n       . withTagFactory ( new   DetailedDimension ( geo ,   enabled ,   context :: getGeo )) \n       . withTagFactory ( new   DetailedDimension ( device ,   enabled ,   context :: getDevice )); \n     rps   =   factory . counter ( rpsId ); \n   } \n\n   public   Response   handle ( Request   request )   { \n     fillInContext ( request ); \n     Response   response   =   process ( request ); \n     fillInContext ( response ); \n\n     // Update the counter, the placeholders will be resolved when the activity, in \n     // this case the increment is called. \n     rps . increment (); \n     return   response ; \n   } \n\n   // Tag factory that can be controlled with an enabled property. \n   private   static   class   DetailedDimension   implements   TagFactory   { \n\n     private   final   String   name ; \n     private   final   Supplier String   valueFunc ; \n\n     DetailedDimension ( String   name ,   Property Boolean   enabled ,   Supplier String   valueFunc )   { \n       this . name   =   name ; \n       this . enabled   =   enabled ; \n       this . valueFunc   =   valueFunc ; \n     } \n\n     @Override   public   String   name ()   { \n       return   name ; \n     } \n\n     @Override   public   Tag   createTag ()   { \n       return   enabled . get () \n           ?   new   BasicTag ( name ,   valueFunc . get ()) \n           :   null ; \n     } \n   }  }", 
            "title": "Usage"
        }, 
        {
            "location": "/registry/metrics3/", 
            "text": "Metrics3 Registry\n\n\nRegistry that uses \nmetrics3\n as the\nunderlying implementation. To use the metrics registry, add a dependency on the\n\nspectator-reg-metrics3\n library. For gradle:\n\n\ncom.netflix.spectator:spectator-reg-metrics3:0.58.0\n\n\n\n\n\nThen when initializing the application, use the \nMetricsRegistry\n. For more\ninformation see the \nmetrics3 example\n.", 
            "title": "Metrics3"
        }, 
        {
            "location": "/registry/metrics3/#metrics3-registry", 
            "text": "Registry that uses  metrics3  as the\nunderlying implementation. To use the metrics registry, add a dependency on the spectator-reg-metrics3  library. For gradle:  com.netflix.spectator:spectator-reg-metrics3:0.58.0  Then when initializing the application, use the  MetricsRegistry . For more\ninformation see the  metrics3 example .", 
            "title": "Metrics3 Registry"
        }, 
        {
            "location": "/registry/servo/", 
            "text": "Servo Registry\n\n\nRegistry that uses \nservo\n as the underlying\nimplementation. To use the servo registry, add a dependency on the\n\nspectator-reg-servo\n library. For gradle:\n\n\ncom.netflix.spectator:spectator-reg-servo:0.58.0\n\n\n\n\n\nThen when initializing the application, use the \nServoRegistry\n. If using guice\nthen that would look like:\n\n\nInjector\n \ninjector\n \n=\n \nGuice\n.\ncreateInjector\n(\nnew\n \nAbstractModule\n()\n \n{\n\n    \n@Override\n \nprotected\n \nvoid\n \nconfigure\n()\n \n{\n\n    \n}\n\n\n    \n@Provides\n\n    \n@Singleton\n\n    \nprivate\n \nRegistry\n \nprovidesRegistry\n()\n \n{\n\n      \nreturn\n \nnew\n \nServoRegistry\n();\n\n    \n}\n\n  \n});\n\n\n\n\n\n\nFor more information see the \nservo example\n. Note if running internally at Netflix see the\n\nNetflix Integration\n docs instead.", 
            "title": "Servo"
        }, 
        {
            "location": "/registry/servo/#servo-registry", 
            "text": "Registry that uses  servo  as the underlying\nimplementation. To use the servo registry, add a dependency on the spectator-reg-servo  library. For gradle:  com.netflix.spectator:spectator-reg-servo:0.58.0  Then when initializing the application, use the  ServoRegistry . If using guice\nthen that would look like:  Injector   injector   =   Guice . createInjector ( new   AbstractModule ()   { \n     @Override   protected   void   configure ()   { \n     } \n\n     @Provides \n     @Singleton \n     private   Registry   providesRegistry ()   { \n       return   new   ServoRegistry (); \n     } \n   });   For more information see the  servo example . Note if running internally at Netflix see the Netflix Integration  docs instead.", 
            "title": "Servo Registry"
        }, 
        {
            "location": "/reports/", 
            "text": "Build Reports\n\n\nThese are automated reports generated from the build.\n\n\nspectator-agent\n\n\n\n\nJavaDoc\n\n\nTests\n\n\nCoverage\n\n\nPMD\n\n\nFindBugs\n\n\n\n\nspectator-api\n\n\n\n\nJavaDoc\n\n\nTests\n\n\nCoverage\n\n\nPMD\n\n\nFindBugs\n\n\n\n\nspectator-ext-aws\n\n\n\n\nJavaDoc\n\n\nTests\n\n\nCoverage\n\n\nPMD\n\n\nFindBugs\n\n\n\n\nspectator-ext-aws2\n\n\n\n\nJavaDoc\n\n\nTests\n\n\nCoverage\n\n\nPMD\n\n\nFindBugs\n\n\n\n\nspectator-ext-gc\n\n\n\n\nJavaDoc\n\n\nTests\n\n\nCoverage\n\n\nPMD\n\n\nFindBugs\n\n\n\n\nspectator-ext-jvm\n\n\n\n\nJavaDoc\n\n\nTests\n\n\nCoverage\n\n\nPMD\n\n\nFindBugs\n\n\n\n\nspectator-ext-log4j1\n\n\n\n\nJavaDoc\n\n\nTests\n\n\nCoverage\n\n\nPMD\n\n\nFindBugs\n\n\n\n\nspectator-ext-log4j2\n\n\n\n\nJavaDoc\n\n\nTests\n\n\nCoverage\n\n\nPMD\n\n\nFindBugs\n\n\n\n\nspectator-ext-placeholders\n\n\n\n\nJavaDoc\n\n\nTests\n\n\nCoverage\n\n\nPMD\n\n\nFindBugs\n\n\n\n\nspectator-ext-sandbox\n\n\n\n\nJavaDoc\n\n\nTests\n\n\nCoverage\n\n\nPMD\n\n\nFindBugs\n\n\n\n\nspectator-ext-spark\n\n\n\n\nJavaDoc\n\n\nTests\n\n\nCoverage\n\n\nPMD\n\n\nFindBugs\n\n\n\n\nspectator-nflx\n\n\n\n\nJavaDoc\n\n\nTests\n\n\nCoverage\n\n\nPMD\n\n\nFindBugs\n\n\n\n\nspectator-nflx-plugin\n\n\n\n\nJavaDoc\n\n\nTests\n\n\nCoverage\n\n\nPMD\n\n\nFindBugs\n\n\n\n\nspectator-perf\n\n\n\n\nJavaDoc\n\n\nTests\n\n\nCoverage\n\n\nPMD\n\n\nFindBugs\n\n\n\n\nspectator-reg-atlas\n\n\n\n\nJavaDoc\n\n\nTests\n\n\nCoverage\n\n\nPMD\n\n\nFindBugs\n\n\n\n\nspectator-reg-metrics3\n\n\n\n\nJavaDoc\n\n\nTests\n\n\nCoverage\n\n\nPMD\n\n\nFindBugs\n\n\n\n\nspectator-reg-servo\n\n\n\n\nJavaDoc\n\n\nTests\n\n\nCoverage\n\n\nPMD\n\n\nFindBugs\n\n\n\n\nspectator-web-spring\n\n\n\n\nJavaDoc\n\n\nTests\n\n\nCoverage\n\n\nPMD\n\n\nFindBugs", 
            "title": "Build Reports"
        }, 
        {
            "location": "/reports/#build-reports", 
            "text": "These are automated reports generated from the build.", 
            "title": "Build Reports"
        }, 
        {
            "location": "/reports/#spectator-agent", 
            "text": "JavaDoc  Tests  Coverage  PMD  FindBugs", 
            "title": "spectator-agent"
        }, 
        {
            "location": "/reports/#spectator-api", 
            "text": "JavaDoc  Tests  Coverage  PMD  FindBugs", 
            "title": "spectator-api"
        }, 
        {
            "location": "/reports/#spectator-ext-aws", 
            "text": "JavaDoc  Tests  Coverage  PMD  FindBugs", 
            "title": "spectator-ext-aws"
        }, 
        {
            "location": "/reports/#spectator-ext-aws2", 
            "text": "JavaDoc  Tests  Coverage  PMD  FindBugs", 
            "title": "spectator-ext-aws2"
        }, 
        {
            "location": "/reports/#spectator-ext-gc", 
            "text": "JavaDoc  Tests  Coverage  PMD  FindBugs", 
            "title": "spectator-ext-gc"
        }, 
        {
            "location": "/reports/#spectator-ext-jvm", 
            "text": "JavaDoc  Tests  Coverage  PMD  FindBugs", 
            "title": "spectator-ext-jvm"
        }, 
        {
            "location": "/reports/#spectator-ext-log4j1", 
            "text": "JavaDoc  Tests  Coverage  PMD  FindBugs", 
            "title": "spectator-ext-log4j1"
        }, 
        {
            "location": "/reports/#spectator-ext-log4j2", 
            "text": "JavaDoc  Tests  Coverage  PMD  FindBugs", 
            "title": "spectator-ext-log4j2"
        }, 
        {
            "location": "/reports/#spectator-ext-placeholders", 
            "text": "JavaDoc  Tests  Coverage  PMD  FindBugs", 
            "title": "spectator-ext-placeholders"
        }, 
        {
            "location": "/reports/#spectator-ext-sandbox", 
            "text": "JavaDoc  Tests  Coverage  PMD  FindBugs", 
            "title": "spectator-ext-sandbox"
        }, 
        {
            "location": "/reports/#spectator-ext-spark", 
            "text": "JavaDoc  Tests  Coverage  PMD  FindBugs", 
            "title": "spectator-ext-spark"
        }, 
        {
            "location": "/reports/#spectator-nflx", 
            "text": "JavaDoc  Tests  Coverage  PMD  FindBugs", 
            "title": "spectator-nflx"
        }, 
        {
            "location": "/reports/#spectator-nflx-plugin", 
            "text": "JavaDoc  Tests  Coverage  PMD  FindBugs", 
            "title": "spectator-nflx-plugin"
        }, 
        {
            "location": "/reports/#spectator-perf", 
            "text": "JavaDoc  Tests  Coverage  PMD  FindBugs", 
            "title": "spectator-perf"
        }, 
        {
            "location": "/reports/#spectator-reg-atlas", 
            "text": "JavaDoc  Tests  Coverage  PMD  FindBugs", 
            "title": "spectator-reg-atlas"
        }, 
        {
            "location": "/reports/#spectator-reg-metrics3", 
            "text": "JavaDoc  Tests  Coverage  PMD  FindBugs", 
            "title": "spectator-reg-metrics3"
        }, 
        {
            "location": "/reports/#spectator-reg-servo", 
            "text": "JavaDoc  Tests  Coverage  PMD  FindBugs", 
            "title": "spectator-reg-servo"
        }, 
        {
            "location": "/reports/#spectator-web-spring", 
            "text": "JavaDoc  Tests  Coverage  PMD  FindBugs", 
            "title": "spectator-web-spring"
        }
    ]
}