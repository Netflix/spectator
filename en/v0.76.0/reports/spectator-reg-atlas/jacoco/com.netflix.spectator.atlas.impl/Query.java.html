<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Query.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spectator-reg-atlas</a> &gt; <a href="index.source.html" class="el_package">com.netflix.spectator.atlas.impl</a> &gt; <span class="el_source">Query.java</span></div><h1>Query.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2014-2017 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.netflix.spectator.atlas.impl;

import com.netflix.spectator.api.Id;
import com.netflix.spectator.api.Tag;
import com.netflix.spectator.impl.Preconditions;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * Query for matching based on tags. For more information see:
 *
 * https://github.com/Netflix/atlas/wiki/Stack-Language#query
 *
 * &lt;b&gt;Classes in this package are only intended for use internally within spectator. They may
 * change at any time and without notice.&lt;/b&gt;
 */
public interface Query {

  /** Convert {@code id} to a map. */
  static Map&lt;String, String&gt; toMap(Id id) {
<span class="fc" id="L41">    Map&lt;String, String&gt; tags = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L42" title="All 2 branches covered.">    for (Tag t : id.tags()) {</span>
<span class="fc" id="L43">      tags.put(t.key(), t.value());</span>
<span class="fc" id="L44">    }</span>
<span class="fc" id="L45">    tags.put(&quot;name&quot;, id.name());</span>
<span class="fc" id="L46">    return tags;</span>
  }

  /**
   * Check to see if this query matches a set of tags. Common tags or changes to fix
   * invalid characters should be performed prior to checking for a match.
   *
   * @param tags
   *     Tags to use when checking for a match.
   * @return
   *     True if the query expression matches the tag map.
   */
  boolean matches(Map&lt;String, String&gt; tags);

  /**
   * Check to see if this query matches an id. Equivalent to calling {@link #matches(Map)}
   * with the result of {@link #toMap(Id)}.
   *
   * @param id
   *     Id to use when checking for a match.
   * @return
   *     True if the query expression matches the id.
   */
  default boolean matches(Id id) {
<span class="fc" id="L70">    return matches(toMap(id));</span>
  }

  /**
   * Extract the tags from the query that have an exact match for a given value. That
   * is are specified using an {@link Equal} clause.
   *
   * @return
   *     Tags that are exactly matched as part of the query.
   */
  default Map&lt;String, String&gt; exactTags() {
<span class="fc" id="L81">    return Collections.emptyMap();</span>
  }

  /** Returns a new query: {@code this AND q}. */
  default Query and(Query q) {
<span class="nc" id="L86">    return new And(this, q);</span>
  }

  /** Returns a new query: {@code this OR q}. */
  default Query or(Query q) {
<span class="nc" id="L91">    return new Or(this, q);</span>
  }

  /** Returns an inverted version of this query. */
  default Query not() {
<span class="nc" id="L96">    return new Not(this);</span>
  }

  /** Query that always matches. */
<span class="fc" id="L100">  Query TRUE = new Query() {</span>
    @Override public boolean matches(Map&lt;String, String&gt; tags) {
<span class="fc" id="L102">      return true;</span>
    }

    @Override public String toString() {
<span class="fc" id="L106">      return &quot;:true&quot;;</span>
    }
  };

  /** Query that never matches. */
<span class="fc" id="L111">  Query FALSE = new Query() {</span>
    @Override public boolean matches(Map&lt;String, String&gt; tags) {
<span class="fc" id="L113">      return false;</span>
    }

    @Override public String toString() {
<span class="fc" id="L117">      return &quot;:false&quot;;</span>
    }
  };

  /** Query that matches if both sub-queries match. */
  final class And implements Query {
    private final Query q1;
    private final Query q2;

    /** Create a new instance. */
<span class="fc" id="L127">    And(Query q1, Query q2) {</span>
<span class="fc" id="L128">      this.q1 = Preconditions.checkNotNull(q1, &quot;q1&quot;);</span>
<span class="fc" id="L129">      this.q2 = Preconditions.checkNotNull(q2, &quot;q2&quot;);</span>
<span class="fc" id="L130">    }</span>

    @Override public boolean matches(Map&lt;String, String&gt; tags) {
<span class="fc bfc" id="L133" title="All 4 branches covered.">      return q1.matches(tags) &amp;&amp; q2.matches(tags);</span>
    }

    @Override public Map&lt;String, String&gt; exactTags() {
<span class="nc" id="L137">      Map&lt;String, String&gt; tags = new HashMap&lt;&gt;();</span>
<span class="nc" id="L138">      tags.putAll(q1.exactTags());</span>
<span class="nc" id="L139">      tags.putAll(q2.exactTags());</span>
<span class="nc" id="L140">      return tags;</span>
    }

    @Override public String toString() {
<span class="fc" id="L144">      return q1 + &quot;,&quot; + q2 + &quot;,:and&quot;;</span>
    }

    @Override public boolean equals(Object obj) {
<span class="fc bfc" id="L148" title="All 2 branches covered.">      if (this == obj) return true;</span>
<span class="fc bfc" id="L149" title="All 4 branches covered.">      if (obj == null || !(obj instanceof And)) return false;</span>
<span class="fc" id="L150">      And other = (And) obj;</span>
<span class="fc bfc" id="L151" title="All 4 branches covered.">      return q1.equals(other.q1) &amp;&amp; q2.equals(other.q2);</span>
    }

    @Override public int hashCode() {
<span class="fc" id="L155">      int result = q1.hashCode();</span>
<span class="fc" id="L156">      result = 31 * result + q2.hashCode();</span>
<span class="fc" id="L157">      return result;</span>
    }
  }

  /** Query that matches if either sub-queries match. */
  final class Or implements Query {
    private final Query q1;
    private final Query q2;

    /** Create a new instance. */
<span class="fc" id="L167">    Or(Query q1, Query q2) {</span>
<span class="fc" id="L168">      this.q1 = Preconditions.checkNotNull(q1, &quot;q1&quot;);</span>
<span class="fc" id="L169">      this.q2 = Preconditions.checkNotNull(q2, &quot;q2&quot;);</span>
<span class="fc" id="L170">    }</span>

    @Override public boolean matches(Map&lt;String, String&gt; tags) {
<span class="fc bfc" id="L173" title="All 4 branches covered.">      return q1.matches(tags) || q2.matches(tags);</span>
    }

    @Override public String toString() {
<span class="fc" id="L177">      return q1 + &quot;,&quot; + q2 + &quot;,:or&quot;;</span>
    }

    @Override public boolean equals(Object obj) {
<span class="fc bfc" id="L181" title="All 2 branches covered.">      if (this == obj) return true;</span>
<span class="fc bfc" id="L182" title="All 4 branches covered.">      if (obj == null || !(obj instanceof Or)) return false;</span>
<span class="fc" id="L183">      Or other = (Or) obj;</span>
<span class="fc bfc" id="L184" title="All 4 branches covered.">      return q1.equals(other.q1) &amp;&amp; q2.equals(other.q2);</span>
    }

    @Override public int hashCode() {
<span class="fc" id="L188">      int result = q1.hashCode();</span>
<span class="fc" id="L189">      result = 31 * result + q2.hashCode();</span>
<span class="fc" id="L190">      return result;</span>
    }
  }

  /** Query that matches if the sub-query does not match. */
  final class Not implements Query {
    private final Query q;

    /** Create a new instance. */
<span class="fc" id="L199">    Not(Query q) {</span>
<span class="fc" id="L200">      this.q = Preconditions.checkNotNull(q, &quot;q&quot;);</span>
<span class="fc" id="L201">    }</span>

    @Override public boolean matches(Map&lt;String, String&gt; tags) {
<span class="fc bfc" id="L204" title="All 2 branches covered.">      return !q.matches(tags);</span>
    }

    @Override public String toString() {
<span class="fc" id="L208">      return q + &quot;,:not&quot;;</span>
    }

    @Override public boolean equals(Object obj) {
<span class="fc bfc" id="L212" title="All 2 branches covered.">      if (this == obj) return true;</span>
<span class="fc bfc" id="L213" title="All 4 branches covered.">      if (obj == null || !(obj instanceof Not)) return false;</span>
<span class="fc" id="L214">      Not other = (Not) obj;</span>
<span class="fc" id="L215">      return q.equals(other.q);</span>
    }

    @Override public int hashCode() {
<span class="fc" id="L219">      return q.hashCode();</span>
    }
  }

  /** Query that matches if the tag map contains a specified key. */
  final class Has implements Query {
    private final String k;

    /** Create a new instance. */
<span class="fc" id="L228">    Has(String k) {</span>
<span class="fc" id="L229">      this.k = Preconditions.checkNotNull(k, &quot;k&quot;);</span>
<span class="fc" id="L230">    }</span>

    @Override public boolean matches(Map&lt;String, String&gt; tags) {
<span class="fc" id="L233">      return tags.containsKey(k);</span>
    }

    @Override public String toString() {
<span class="fc" id="L237">      return k + &quot;,:has&quot;;</span>
    }

    @Override public boolean equals(Object obj) {
<span class="fc bfc" id="L241" title="All 2 branches covered.">      if (this == obj) return true;</span>
<span class="fc bfc" id="L242" title="All 4 branches covered.">      if (obj == null || !(obj instanceof Has)) return false;</span>
<span class="fc" id="L243">      Has other = (Has) obj;</span>
<span class="fc" id="L244">      return k.equals(other.k);</span>
    }

    @Override public int hashCode() {
<span class="fc" id="L248">      return k.hashCode();</span>
    }
  }

  /** Query that matches if the tag map contains key {@code k} with value {@code v}. */
  final class Equal implements Query {
    private final String k;
    private final String v;

    /** Create a new instance. */
<span class="fc" id="L258">    Equal(String k, String v) {</span>
<span class="fc" id="L259">      this.k = Preconditions.checkNotNull(k, &quot;k&quot;);</span>
<span class="fc" id="L260">      this.v = Preconditions.checkNotNull(v, &quot;v&quot;);</span>
<span class="fc" id="L261">    }</span>

    @Override public boolean matches(Map&lt;String, String&gt; tags) {
<span class="fc" id="L264">      return v.equals(tags.get(k));</span>
    }

    @Override public Map&lt;String, String&gt; exactTags() {
<span class="fc" id="L268">      Map&lt;String, String&gt; tags = new HashMap&lt;&gt;();</span>
<span class="fc" id="L269">      tags.put(k, v);</span>
<span class="fc" id="L270">      return tags;</span>
    }

    @Override public String toString() {
<span class="fc" id="L274">      return k + &quot;,&quot; + v + &quot;,:eq&quot;;</span>
    }

    @Override public boolean equals(Object obj) {
<span class="fc bfc" id="L278" title="All 2 branches covered.">      if (this == obj) return true;</span>
<span class="fc bfc" id="L279" title="All 4 branches covered.">      if (obj == null || !(obj instanceof Equal)) return false;</span>
<span class="fc" id="L280">      Equal other = (Equal) obj;</span>
<span class="fc bfc" id="L281" title="All 4 branches covered.">      return k.equals(other.k) &amp;&amp; v.equals(other.v);</span>
    }

    @Override public int hashCode() {
<span class="fc" id="L285">      int result = k.hashCode();</span>
<span class="fc" id="L286">      result = 31 * result + v.hashCode();</span>
<span class="fc" id="L287">      return result;</span>
    }
  }

  /**
   * Query that matches if the tag map contains key {@code k} with a value in the set
   * {@code vs}.
   */
  final class In implements Query {
    private final String k;
    private final Set&lt;String&gt; vs;

    /** Create a new instance. */
<span class="fc" id="L300">    In(String k, Set&lt;String&gt; vs) {</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">      Preconditions.checkArg(!vs.isEmpty(), &quot;list of values for :in cannot be empty&quot;);</span>
<span class="fc" id="L302">      this.k = Preconditions.checkNotNull(k, &quot;k&quot;);</span>
<span class="fc" id="L303">      this.vs = Preconditions.checkNotNull(vs, &quot;vs&quot;);</span>
<span class="fc" id="L304">    }</span>

    @Override public boolean matches(Map&lt;String, String&gt; tags) {
<span class="fc" id="L307">      String s = tags.get(k);</span>
<span class="pc bpc" id="L308" title="1 of 4 branches missed.">      return s != null &amp;&amp; vs.contains(tags.get(k));</span>
    }

    @Override public String toString() {
<span class="fc" id="L312">      String values = vs.stream().collect(Collectors.joining(&quot;,&quot;));</span>
<span class="fc" id="L313">      return k + &quot;,(,&quot; + values + &quot;,),:in&quot;;</span>
    }

    @Override public boolean equals(Object obj) {
<span class="fc bfc" id="L317" title="All 2 branches covered.">      if (this == obj) return true;</span>
<span class="fc bfc" id="L318" title="All 4 branches covered.">      if (obj == null || !(obj instanceof In)) return false;</span>
<span class="fc" id="L319">      In other = (In) obj;</span>
<span class="fc bfc" id="L320" title="All 4 branches covered.">      return k.equals(other.k) &amp;&amp; vs.equals(other.vs);</span>
    }

    @Override public int hashCode() {
<span class="fc" id="L324">      int result = k.hashCode();</span>
<span class="fc" id="L325">      result = 31 * result + vs.hashCode();</span>
<span class="fc" id="L326">      return result;</span>
    }
  }

  /**
   * Query that matches if the tag map contains key {@code k} with a value that is lexically
   * less than {@code v}.
   */
  final class LessThan implements Query {
    private final String k;
    private final String v;

    /** Create a new instance. */
<span class="fc" id="L339">    LessThan(String k, String v) {</span>
<span class="fc" id="L340">      this.k = Preconditions.checkNotNull(k, &quot;k&quot;);</span>
<span class="fc" id="L341">      this.v = Preconditions.checkNotNull(v, &quot;v&quot;);</span>
<span class="fc" id="L342">    }</span>

    @Override public boolean matches(Map&lt;String, String&gt; tags) {
<span class="fc" id="L345">      String s = tags.get(k);</span>
<span class="pc bpc" id="L346" title="1 of 4 branches missed.">      return s != null &amp;&amp; s.compareTo(v) &lt; 0;</span>
    }

    @Override public String toString() {
<span class="fc" id="L350">      return k + &quot;,&quot; + v + &quot;,:lt&quot;;</span>
    }

    @Override public boolean equals(Object obj) {
<span class="fc bfc" id="L354" title="All 2 branches covered.">      if (this == obj) return true;</span>
<span class="fc bfc" id="L355" title="All 4 branches covered.">      if (obj == null || !(obj instanceof LessThan)) return false;</span>
<span class="fc" id="L356">      LessThan other = (LessThan) obj;</span>
<span class="fc bfc" id="L357" title="All 4 branches covered.">      return k.equals(other.k) &amp;&amp; v.equals(other.v);</span>
    }

    @Override public int hashCode() {
<span class="fc" id="L361">      int result = k.hashCode();</span>
<span class="fc" id="L362">      result = 31 * result + v.hashCode();</span>
<span class="fc" id="L363">      return result;</span>
    }
  }

  /**
   * Query that matches if the tag map contains key {@code k} with a value that is lexically
   * less than or equal to {@code v}.
   */
  final class LessThanEqual implements Query {
    private final String k;
    private final String v;

    /** Create a new instance. */
<span class="fc" id="L376">    LessThanEqual(String k, String v) {</span>
<span class="fc" id="L377">      this.k = Preconditions.checkNotNull(k, &quot;k&quot;);</span>
<span class="fc" id="L378">      this.v = Preconditions.checkNotNull(v, &quot;v&quot;);</span>
<span class="fc" id="L379">    }</span>

    @Override public boolean matches(Map&lt;String, String&gt; tags) {
<span class="fc" id="L382">      String s = tags.get(k);</span>
<span class="pc bpc" id="L383" title="1 of 4 branches missed.">      return s != null &amp;&amp; s.compareTo(v) &lt;= 0;</span>
    }

    @Override public String toString() {
<span class="fc" id="L387">      return k + &quot;,&quot; + v + &quot;,:le&quot;;</span>
    }

    @Override public boolean equals(Object obj) {
<span class="fc bfc" id="L391" title="All 2 branches covered.">      if (this == obj) return true;</span>
<span class="fc bfc" id="L392" title="All 4 branches covered.">      if (obj == null || !(obj instanceof LessThanEqual)) return false;</span>
<span class="fc" id="L393">      LessThanEqual other = (LessThanEqual) obj;</span>
<span class="fc bfc" id="L394" title="All 4 branches covered.">      return k.equals(other.k) &amp;&amp; v.equals(other.v);</span>
    }

    @Override public int hashCode() {
<span class="fc" id="L398">      int result = k.hashCode();</span>
<span class="fc" id="L399">      result = 31 * result + v.hashCode();</span>
<span class="fc" id="L400">      return result;</span>
    }
  }

  /**
   * Query that matches if the tag map contains key {@code k} with a value that is lexically
   * greater than {@code v}.
   */
  final class GreaterThan implements Query {
    private final String k;
    private final String v;

    /** Create a new instance. */
<span class="fc" id="L413">    GreaterThan(String k, String v) {</span>
<span class="fc" id="L414">      this.k = Preconditions.checkNotNull(k, &quot;k&quot;);</span>
<span class="fc" id="L415">      this.v = Preconditions.checkNotNull(v, &quot;v&quot;);</span>
<span class="fc" id="L416">    }</span>

    @Override public boolean matches(Map&lt;String, String&gt; tags) {
<span class="fc" id="L419">      String s = tags.get(k);</span>
<span class="pc bpc" id="L420" title="1 of 4 branches missed.">      return s != null &amp;&amp; s.compareTo(v) &gt; 0;</span>
    }

    @Override public String toString() {
<span class="fc" id="L424">      return k + &quot;,&quot; + v + &quot;,:gt&quot;;</span>
    }

    @Override public boolean equals(Object obj) {
<span class="fc bfc" id="L428" title="All 2 branches covered.">      if (this == obj) return true;</span>
<span class="fc bfc" id="L429" title="All 4 branches covered.">      if (obj == null || !(obj instanceof GreaterThan)) return false;</span>
<span class="fc" id="L430">      GreaterThan other = (GreaterThan) obj;</span>
<span class="fc bfc" id="L431" title="All 4 branches covered.">      return k.equals(other.k) &amp;&amp; v.equals(other.v);</span>
    }

    @Override public int hashCode() {
<span class="fc" id="L435">      int result = k.hashCode();</span>
<span class="fc" id="L436">      result = 31 * result + v.hashCode();</span>
<span class="fc" id="L437">      return result;</span>
    }
  }

  /**
   * Query that matches if the tag map contains key {@code k} with a value that is lexically
   * greater than or equal to {@code v}.
   */
  final class GreaterThanEqual implements Query {
    private final String k;
    private final String v;

    /** Create a new instance. */
<span class="fc" id="L450">    GreaterThanEqual(String k, String v) {</span>
<span class="fc" id="L451">      this.k = Preconditions.checkNotNull(k, &quot;k&quot;);</span>
<span class="fc" id="L452">      this.v = Preconditions.checkNotNull(v, &quot;v&quot;);</span>
<span class="fc" id="L453">    }</span>

    @Override public boolean matches(Map&lt;String, String&gt; tags) {
<span class="fc" id="L456">      String s = tags.get(k);</span>
<span class="pc bpc" id="L457" title="1 of 4 branches missed.">      return s != null &amp;&amp; s.compareTo(v) &gt;= 0;</span>
    }

    @Override public String toString() {
<span class="fc" id="L461">      return k + &quot;,&quot; + v + &quot;,:ge&quot;;</span>
    }

    @Override public boolean equals(Object obj) {
<span class="fc bfc" id="L465" title="All 2 branches covered.">      if (this == obj) return true;</span>
<span class="fc bfc" id="L466" title="All 4 branches covered.">      if (obj == null || !(obj instanceof GreaterThanEqual)) return false;</span>
<span class="fc" id="L467">      GreaterThanEqual other = (GreaterThanEqual) obj;</span>
<span class="fc bfc" id="L468" title="All 4 branches covered.">      return k.equals(other.k) &amp;&amp; v.equals(other.v);</span>
    }

    @Override public int hashCode() {
<span class="fc" id="L472">      int result = k.hashCode();</span>
<span class="fc" id="L473">      result = 31 * result + v.hashCode();</span>
<span class="fc" id="L474">      return result;</span>
    }
  }

  /**
   * Query that matches if the tag map contains key {@code k} with a value that matches the
   * regex in {@code v}. The expression will be automatically anchored to the start to encourage
   * prefix matches.
   *
   * &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; regular expressions are often expensive and can add a lot of overhead.
   * Use them sparingly.&lt;/p&gt;
   */
  final class Regex implements Query {
    private final String k;
    private final String v;
    private final Pattern pattern;
    private final String name;

    /** Create a new instance. */
    Regex(String k, String v) {
<span class="fc" id="L494">      this(k, v, 0, &quot;:re&quot;);</span>
<span class="fc" id="L495">    }</span>

    /** Create a new instance. */
<span class="fc" id="L498">    Regex(String k, String v, int flags, String name) {</span>
<span class="fc" id="L499">      this.k = Preconditions.checkNotNull(k, &quot;k&quot;);</span>
<span class="fc" id="L500">      this.v = Preconditions.checkNotNull(v, &quot;v&quot;);</span>
<span class="fc" id="L501">      this.pattern = Pattern.compile(&quot;^&quot; + v, flags);</span>
<span class="fc" id="L502">      this.name = Preconditions.checkNotNull(name, &quot;name&quot;);</span>
<span class="fc" id="L503">    }</span>

    @Override public boolean matches(Map&lt;String, String&gt; tags) {
<span class="fc" id="L506">      String s = tags.get(k);</span>
<span class="pc bpc" id="L507" title="1 of 4 branches missed.">      return s != null &amp;&amp; pattern.matcher(s).find();</span>
    }

    @Override public String toString() {
<span class="fc" id="L511">      return k + &quot;,&quot; + v + &quot;,&quot; + name;</span>
    }

    @Override public boolean equals(Object obj) {
<span class="fc bfc" id="L515" title="All 2 branches covered.">      if (this == obj) return true;</span>
<span class="fc bfc" id="L516" title="All 4 branches covered.">      if (obj == null || !(obj instanceof Regex)) return false;</span>
<span class="fc" id="L517">      Regex other = (Regex) obj;</span>
<span class="fc bfc" id="L518" title="All 2 branches covered.">      return k.equals(other.k)</span>
<span class="fc bfc" id="L519" title="All 2 branches covered.">          &amp;&amp; v.equals(other.v)</span>
<span class="pc bpc" id="L520" title="1 of 2 branches missed.">          &amp;&amp; pattern.flags() == other.pattern.flags()</span>
<span class="fc bfc" id="L521" title="All 2 branches covered.">          &amp;&amp; name.equals(other.name);</span>
    }

    @Override public int hashCode() {
<span class="fc" id="L525">      int result = k.hashCode();</span>
<span class="fc" id="L526">      result = 31 * result + v.hashCode();</span>
<span class="fc" id="L527">      result = 31 * result + pattern.flags();</span>
<span class="fc" id="L528">      result = 31 * result + name.hashCode();</span>
<span class="fc" id="L529">      return result;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>