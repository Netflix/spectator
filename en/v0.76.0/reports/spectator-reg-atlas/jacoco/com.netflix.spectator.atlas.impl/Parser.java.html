<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Parser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spectator-reg-atlas</a> &gt; <a href="index.source.html" class="el_package">com.netflix.spectator.atlas.impl</a> &gt; <span class="el_source">Parser.java</span></div><h1>Parser.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2014-2017 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.netflix.spectator.atlas.impl;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.List;
import java.util.TreeSet;
import java.util.regex.Pattern;

/**
 * Parses an Atlas data or query expression.
 *
 * &lt;b&gt;Classes in this package are only intended for use internally within spectator. They may
 * change at any time and without notice.&lt;/b&gt;
 */
public final class Parser {

  private Parser() {
  }

  /**
   * Parse an &lt;a href=&quot;https://github.com/Netflix/atlas/wiki/Reference-data&quot;&gt;Atlas data
   * expression&lt;/a&gt;.
   */
  public static DataExpr parseDataExpr(String expr) {
    try {
<span class="fc" id="L42">      return (DataExpr) parse(expr);</span>
<span class="fc" id="L43">    } catch (ClassCastException e) {</span>
<span class="fc" id="L44">      throw new IllegalArgumentException(&quot;invalid data expression: &quot; + expr, e);</span>
    }
  }

  /**
   * Parse an &lt;a href=&quot;https://github.com/Netflix/atlas/wiki/Reference-query&quot;&gt;Atlas query
   * expression&lt;/a&gt;.
   */
  public static Query parseQuery(String expr) {
    try {
<span class="fc" id="L54">      return (Query) parse(expr);</span>
<span class="nc" id="L55">    } catch (ClassCastException e) {</span>
<span class="nc" id="L56">      throw new IllegalArgumentException(&quot;invalid query expression: &quot; + expr, e);</span>
    }
  }

  @SuppressWarnings({&quot;unchecked&quot;, &quot;PMD&quot;})
  private static Object parse(String expr) {
    DataExpr.AggregateFunction af;
    Query q, q1, q2;
    String k, v;
<span class="fc" id="L65">    int depth = 0;</span>
    List&lt;String&gt; tmp;
<span class="fc" id="L67">    List&lt;String&gt; vs = null;</span>
<span class="fc" id="L68">    String[] parts = expr.split(&quot;,&quot;);</span>
<span class="fc" id="L69">    Deque&lt;Object&gt; stack = new ArrayDeque&lt;&gt;(parts.length);</span>
<span class="fc bfc" id="L70" title="All 2 branches covered.">    for (String p : parts) {</span>
<span class="fc" id="L71">      String token = p.trim();</span>
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">      if (token.isEmpty()) {</span>
<span class="nc" id="L73">        continue;</span>
      }
<span class="fc bfc" id="L75" title="All 6 branches covered.">      if (vs != null &amp;&amp; (depth &gt; 0 || !&quot;)&quot;.equals(token))) {</span>
<span class="fc bfc" id="L76" title="All 2 branches covered.">        if (&quot;(&quot;.equals(token)) {</span>
<span class="fc" id="L77">          ++depth;</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">        } else if (&quot;)&quot;.equals(token)) {</span>
<span class="fc" id="L79">          --depth;</span>
        }
<span class="fc" id="L81">        vs.add(token);</span>
<span class="fc" id="L82">        continue;</span>
      }
<span class="fc bfc" id="L84" title="All 25 branches covered.">      switch (token) {</span>
        case &quot;(&quot;:
<span class="fc" id="L86">          vs = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L87">          break;</span>
        case &quot;)&quot;:
<span class="fc bfc" id="L89" title="All 2 branches covered.">          if (vs == null) {</span>
<span class="fc" id="L90">            throw new IllegalArgumentException(&quot;unmatched closing paren: &quot; + expr);</span>
          }
<span class="fc" id="L92">          stack.push(vs);</span>
<span class="fc" id="L93">          vs = null;</span>
<span class="fc" id="L94">          depth = 0;</span>
<span class="fc" id="L95">          break;</span>
        case &quot;:true&quot;:
<span class="fc" id="L97">          stack.push(Query.TRUE);</span>
<span class="fc" id="L98">          break;</span>
        case &quot;:false&quot;:
<span class="fc" id="L100">          stack.push(Query.FALSE);</span>
<span class="fc" id="L101">          break;</span>
        case &quot;:and&quot;:
<span class="fc" id="L103">          q2 = (Query) stack.pop();</span>
<span class="fc" id="L104">          q1 = (Query) stack.pop();</span>
<span class="fc" id="L105">          stack.push(new Query.And(q1, q2));</span>
<span class="fc" id="L106">          break;</span>
        case &quot;:or&quot;:
<span class="fc" id="L108">          q2 = (Query) stack.pop();</span>
<span class="fc" id="L109">          q1 = (Query) stack.pop();</span>
<span class="fc" id="L110">          stack.push(new Query.Or(q1, q2));</span>
<span class="fc" id="L111">          break;</span>
        case &quot;:not&quot;:
<span class="fc" id="L113">          q = (Query) stack.pop();</span>
<span class="fc" id="L114">          stack.push(new Query.Not(q));</span>
<span class="fc" id="L115">          break;</span>
        case &quot;:has&quot;:
<span class="fc" id="L117">          k = (String) stack.pop();</span>
<span class="fc" id="L118">          stack.push(new Query.Has(k));</span>
<span class="fc" id="L119">          break;</span>
        case &quot;:eq&quot;:
<span class="fc" id="L121">          v = (String) stack.pop();</span>
<span class="fc" id="L122">          k = (String) stack.pop();</span>
<span class="fc" id="L123">          stack.push(new Query.Equal(k, v));</span>
<span class="fc" id="L124">          break;</span>
        case &quot;:in&quot;:
<span class="fc" id="L126">          tmp = (List&lt;String&gt;) stack.pop();</span>
<span class="fc" id="L127">          k = (String) stack.pop();</span>
<span class="fc" id="L128">          stack.push(new Query.In(k, new TreeSet&lt;&gt;(tmp)));</span>
<span class="fc" id="L129">          break;</span>
        case &quot;:lt&quot;:
<span class="fc" id="L131">          v = (String) stack.pop();</span>
<span class="fc" id="L132">          k = (String) stack.pop();</span>
<span class="fc" id="L133">          stack.push(new Query.LessThan(k, v));</span>
<span class="fc" id="L134">          break;</span>
        case &quot;:le&quot;:
<span class="fc" id="L136">          v = (String) stack.pop();</span>
<span class="fc" id="L137">          k = (String) stack.pop();</span>
<span class="fc" id="L138">          stack.push(new Query.LessThanEqual(k, v));</span>
<span class="fc" id="L139">          break;</span>
        case &quot;:gt&quot;:
<span class="fc" id="L141">          v = (String) stack.pop();</span>
<span class="fc" id="L142">          k = (String) stack.pop();</span>
<span class="fc" id="L143">          stack.push(new Query.GreaterThan(k, v));</span>
<span class="fc" id="L144">          break;</span>
        case &quot;:ge&quot;:
<span class="fc" id="L146">          v = (String) stack.pop();</span>
<span class="fc" id="L147">          k = (String) stack.pop();</span>
<span class="fc" id="L148">          stack.push(new Query.GreaterThanEqual(k, v));</span>
<span class="fc" id="L149">          break;</span>
        case &quot;:re&quot;:
<span class="fc" id="L151">          v = (String) stack.pop();</span>
<span class="fc" id="L152">          k = (String) stack.pop();</span>
<span class="fc" id="L153">          stack.push(new Query.Regex(k, v));</span>
<span class="fc" id="L154">          break;</span>
        case &quot;:reic&quot;:
<span class="fc" id="L156">          v = (String) stack.pop();</span>
<span class="fc" id="L157">          k = (String) stack.pop();</span>
<span class="fc" id="L158">          stack.push(new Query.Regex(k, v, Pattern.CASE_INSENSITIVE, &quot;:reic&quot;));</span>
<span class="fc" id="L159">          break;</span>
        case &quot;:all&quot;:
<span class="fc" id="L161">          q = (Query) stack.pop();</span>
<span class="fc" id="L162">          stack.push(new DataExpr.All(q));</span>
<span class="fc" id="L163">          break;</span>
        case &quot;:sum&quot;:
<span class="fc" id="L165">          q = (Query) stack.pop();</span>
<span class="fc" id="L166">          stack.push(new DataExpr.Sum(q));</span>
<span class="fc" id="L167">          break;</span>
        case &quot;:min&quot;:
<span class="fc" id="L169">          q = (Query) stack.pop();</span>
<span class="fc" id="L170">          stack.push(new DataExpr.Min(q));</span>
<span class="fc" id="L171">          break;</span>
        case &quot;:max&quot;:
<span class="fc" id="L173">          q = (Query) stack.pop();</span>
<span class="fc" id="L174">          stack.push(new DataExpr.Max(q));</span>
<span class="fc" id="L175">          break;</span>
        case &quot;:count&quot;:
<span class="fc" id="L177">          q = (Query) stack.pop();</span>
<span class="fc" id="L178">          stack.push(new DataExpr.Count(q));</span>
<span class="fc" id="L179">          break;</span>
        case &quot;:by&quot;:
<span class="fc" id="L181">          tmp = (List&lt;String&gt;) stack.pop();</span>
<span class="fc" id="L182">          af = (DataExpr.AggregateFunction) stack.pop();</span>
<span class="fc" id="L183">          stack.push(new DataExpr.GroupBy(af, tmp));</span>
<span class="fc" id="L184">          break;</span>
        case &quot;:rollup-drop&quot;:
<span class="fc" id="L186">          tmp = (List&lt;String&gt;) stack.pop();</span>
<span class="fc" id="L187">          af = (DataExpr.AggregateFunction) stack.pop();</span>
<span class="fc" id="L188">          stack.push(new DataExpr.DropRollup(af, tmp));</span>
<span class="fc" id="L189">          break;</span>
        case &quot;:rollup-keep&quot;:
<span class="fc" id="L191">          tmp = (List&lt;String&gt;) stack.pop();</span>
<span class="fc" id="L192">          af = (DataExpr.AggregateFunction) stack.pop();</span>
<span class="fc" id="L193">          stack.push(new DataExpr.KeepRollup(af, tmp));</span>
<span class="fc" id="L194">          break;</span>
        default:
<span class="pc bpc" id="L196" title="1 of 2 branches missed.">          if (token.startsWith(&quot;:&quot;)) {</span>
<span class="nc" id="L197">            throw new IllegalArgumentException(&quot;unknown word '&quot; + token + &quot;'&quot;);</span>
          }
<span class="fc" id="L199">          stack.push(token);</span>
          break;
      }
    }
<span class="fc" id="L203">    Object obj = stack.pop();</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">    if (!stack.isEmpty()) {</span>
<span class="nc" id="L205">      throw new IllegalArgumentException(&quot;too many items remaining on stack: &quot; + stack);</span>
    }
<span class="fc" id="L207">    return obj;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>